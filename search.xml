<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kubernetes之service</title>
      <link href="/2019/12/16/kubernetes-zhi-service/"/>
      <url>/2019/12/16/kubernetes-zhi-service/</url>
      
        <content type="html"><![CDATA[<p>通过创建Service, 可以为一组具有相同功能的容器应用提供一个统一的入口地址, 并将请求负载分发到后端的各个容器应用上。</p><h3 id="定义详解"><a href="#定义详解" class="headerlink" title="定义详解"></a>定义详解</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1      // Required<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service       // Required<span class="token key atrule">metadata</span><span class="token punctuation">:</span>           // Required  <span class="token key atrule">name</span><span class="token punctuation">:</span> string      // Required  <span class="token comment" spellcheck="true"># 不指定使用"default"的命名空间</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> string // Required  <span class="token comment" spellcheck="true"># 自定义标签列表</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string  <span class="token comment" spellcheck="true"># 自定义注解属性列表  </span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string  <span class="token comment" spellcheck="true"># 详细描述  </span><span class="token key atrule">spec</span><span class="token punctuation">:</span>             // Required  <span class="token comment" spellcheck="true"># 选择具有指定Label标签的Pod作为管理范围</span>  <span class="token key atrule">selectors</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   // Required  <span class="token comment" spellcheck="true"># 指定Service的访问方式, 默认为ClusterIP(虚拟的服务IP地址)。还可使用NodePort(宿主机IP+端口即可访问), LoadBalancer(使用外接负载均衡器完成到服务的负载分发)</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> string    // Required  <span class="token comment" spellcheck="true"># 当type为LoadBanlancer时, 需要指定。NodePort时如果不指定, 系统自定进行分配。</span>  <span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> string  <span class="token comment" spellcheck="true"># 可选值为ClientIP, 表示将同一客户端的请求转发到同一后端Pod, 默认为空。</span>  <span class="token key atrule">sessionAffinity</span><span class="token punctuation">:</span> string  <span class="token comment" spellcheck="true"># service需要暴露的端口列表</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string    <span class="token comment" spellcheck="true"># 端口协议, TCP/UDP</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> string    <span class="token comment" spellcheck="true"># 服务监听的端口号</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> int    <span class="token comment" spellcheck="true"># 转发到后端Pod的端口号</span>    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> int    <span class="token comment" spellcheck="true"># 当type为NodePort时, 映射到物理机的端口号。</span>    <span class="token key atrule">nodePort</span><span class="token punctuation">:</span> int  <span class="token comment" spellcheck="true"># 当type为LoadBalancer时, 用于设置外部负载均衡器的地址。  </span>  <span class="token key atrule">status</span><span class="token punctuation">:</span>    <span class="token key atrule">loadBalancer</span><span class="token punctuation">:</span>      <span class="token key atrule">ingress</span><span class="token punctuation">:</span>        <span class="token key atrule">ip</span><span class="token punctuation">:</span> string        <span class="token key atrule">hostname</span><span class="token punctuation">:</span> string                                                                </code></pre><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>使用expose快速创建Service的方法。</p><pre class=" language-shell"><code class="language-shell">kubectl expose rc webapp</code></pre><p>还可以通过上述配置文件来定义service。</p><pre class=" language-shell"><code class="language-shell">kubectl create -f webapp-svc.yaml</code></pre><h4 id="负载分发策略"><a href="#负载分发策略" class="headerlink" title="负载分发策略"></a>负载分发策略</h4><ul><li><p>RoundRobin: 轮询模式, 即轮询将请求转发到后端的各个Pod上。</p></li><li><p>SessionAffinity: 基于客户端的IP地址进行会话保持的模式, 可将sessionAffinity设置为<code>ClientIP</code>来启用。</p></li><li><p>自己控制负载均衡策略: 将Service的ClusterIP设置为<code>None</code>(无入口IP地址), 仅通过Label Selector将后端的Pod列表返回给调用的客户端。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">...</span><span class="token key atrule">clusterIP</span><span class="token punctuation">:</span> None<span class="token punctuation">...</span></code></pre></li></ul><h4 id="访问外部服务"><a href="#访问外部服务" class="headerlink" title="访问外部服务"></a>访问外部服务</h4><p>定义一个不带标签选择器的Service, 即无法选择后端的Pod, 此时系统不会自动创建EndPoint, 因此手动创建一个与Service同名的EndPoint, 用于指向实际的后端访问地址。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">kind</span><span class="token punctuation">:</span> Endpoints<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> my<span class="token punctuation">-</span>service<span class="token key atrule">subsets</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">adresses</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">IP</span><span class="token punctuation">:</span> 1.2.3.4      <span class="token key atrule">ports</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><h3 id="DNS服务搭建"><a href="#DNS服务搭建" class="headerlink" title="DNS服务搭建"></a>DNS服务搭建</h3><p>kubernetes提供的虚拟DNS服务名为skydns, 由四个组件组成。</p><ul><li>etcd: DNS存储。</li><li>kube2sky: 将kubernetes Master的Service注册到etcd。</li><li>skyDNS: 提供DNS域名解析服务。</li><li>healthz: 提供对skydns服务的健康检查功能。</li></ul><h3 id="Ingress-HTTP-7层路由机制"><a href="#Ingress-HTTP-7层路由机制" class="headerlink" title="Ingress: HTTP 7层路由机制"></a>Ingress: HTTP 7层路由机制</h3><p>实现HTTP层的业务路由机制, 即不同的URL地址对应到不同的后端服务或者虚拟服务器。</p><p>在kubernetes集群中, Ingress的实现需要通过Ingress的定义与Ingress Controller的定义结合起来, 才能形成完整的HTTP负载分发功能。</p><h4 id="创建Ingress-Controller"><a href="#创建Ingress-Controller" class="headerlink" title="创建Ingress Controller"></a>创建Ingress Controller</h4><p>在定义Ingress之前, 需要先部署Ingress Controller, 以实现为所有后端Service提供一个统一的入口。</p><p>Ingress Controller需要实现基于不同HTTP URL向后转发的负载分发规则, 也可设置能够提供该类型HTTP路由的LoadBalancer为Ingress Controller。</p><p>Ingress Controller以Pod的形式运行, 监控apiserver的/ingress接口, 如果service发生变化, 则Ingress Controller应自动更新其转发规则。</p><h4 id="定义Ingress"><a href="#定义Ingress" class="headerlink" title="定义Ingress"></a>定义Ingress</h4><p>设置到后端Service的转发规则。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes之pod</title>
      <link href="/2019/12/13/kubernetes-zhi-pod/"/>
      <url>/2019/12/13/kubernetes-zhi-pod/</url>
      
        <content type="html"><![CDATA[<h3 id="定义详解"><a href="#定义详解" class="headerlink" title="定义详解"></a>定义详解</h3><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 版本号</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1    <span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod  <span class="token comment" spellcheck="true"># 元数据</span><span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># Pod的名称</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> string  <span class="token comment" spellcheck="true"># 所属的命名空间</span>  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> string      <span class="token comment" spellcheck="true"># 自定义标签列表</span>  <span class="token key atrule">labels</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string  <span class="token comment" spellcheck="true"># 自定义注解列表  </span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>           <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string<span class="token comment" spellcheck="true"># 详细定义    </span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 容器列表</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># 容器名称</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string    <span class="token comment" spellcheck="true"># 容器镜像名称</span>    <span class="token key atrule">image</span><span class="token punctuation">:</span> string    <span class="token comment" spellcheck="true"># 镜像拉取策略: Always、Never、IfNotPresent</span>    <span class="token key atrule">imagePullPolicy</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 容器的启动命令列表, 如果不指定, 则使用镜像打包时使用的启动命令</span>    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>string<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 启动命令参数列表</span>    <span class="token key atrule">args</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>string<span class="token punctuation">]</span>     <span class="token comment" spellcheck="true"># 工作目录</span>    <span class="token key atrule">workingDir</span><span class="token punctuation">:</span> string        <span class="token comment" spellcheck="true"># 挂在到容器内部的存储卷配置</span>    <span class="token key atrule">volumeMounts</span><span class="token punctuation">:</span>         <span class="token comment" spellcheck="true"># 引用Pod定义的共享存储卷的名称, 需使用volumes[]部分定义的共享存储卷名称</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string           <span class="token comment" spellcheck="true"># 存储卷在容器内Mount的绝对路径, 应少于512个字符</span>      <span class="token key atrule">mountPath</span><span class="token punctuation">:</span> string          <span class="token comment" spellcheck="true"># 是否为只读模式, 默认为读写模式</span>      <span class="token key atrule">readOnly</span><span class="token punctuation">:</span> boolean        <span class="token comment" spellcheck="true"># 容器需要暴露的端口号列表  </span>    <span class="token key atrule">ports</span><span class="token punctuation">:</span>             <span class="token comment" spellcheck="true"># 端口的名称</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string       <span class="token comment" spellcheck="true"># 容器需要监听的端口号</span>      <span class="token key atrule">containerPort</span><span class="token punctuation">:</span> int       <span class="token comment" spellcheck="true"># 容器所在主机需要监听的端口号, 默认与containerPort相同, 设置hostPort时, 同一宿主机无法启动该容器的第二副本</span>      <span class="token key atrule">hostPort</span><span class="token punctuation">:</span> int      <span class="token comment" spellcheck="true"># 端口协议, 支持TCP(默认)和UDP</span>      <span class="token key atrule">protocol</span><span class="token punctuation">:</span> string         <span class="token comment" spellcheck="true"># 容器运行前需要设置的环境变量列表  </span>    <span class="token key atrule">env</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 环境变量的名称</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string        <span class="token comment" spellcheck="true"># 环境变量的值</span>      <span class="token key atrule">value</span><span class="token punctuation">:</span> string        <span class="token comment" spellcheck="true"># 资源限制和资源请求的设置  </span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>            <span class="token key atrule">limits</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true"># CPU限制, 单位为core</span>        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> string            <span class="token comment" spellcheck="true"># 内存限制, 单位可以为MiB/GiB等</span>        <span class="token key atrule">memory</span><span class="token punctuation">:</span> string        <span class="token comment" spellcheck="true"># 最低要求</span>      <span class="token key atrule">requests</span><span class="token punctuation">:</span>                <span class="token key atrule">cpu</span><span class="token punctuation">:</span> string            <span class="token key atrule">memory</span><span class="token punctuation">:</span> string    <span class="token comment" spellcheck="true"># 对Pod内容器健康检查的设置    </span>    <span class="token key atrule">livenessProbe</span><span class="token punctuation">:</span>           <span class="token key atrule">exec</span><span class="token punctuation">:</span>              <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>string<span class="token punctuation">]</span>        <span class="token key atrule">httpGet</span><span class="token punctuation">:</span>               <span class="token key atrule">path</span><span class="token punctuation">:</span> string        <span class="token key atrule">port</span><span class="token punctuation">:</span> number        <span class="token key atrule">host</span><span class="token punctuation">:</span> string        <span class="token key atrule">scheme</span><span class="token punctuation">:</span> string        <span class="token key atrule">HttpHeaders</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string          <span class="token key atrule">value</span><span class="token punctuation">:</span> string      <span class="token key atrule">tcpSocket</span><span class="token punctuation">:</span>              <span class="token key atrule">port</span><span class="token punctuation">:</span> number       <span class="token comment" spellcheck="true"># 容器启动完成后进行首次探测的时间, 单位为秒  </span>       <span class="token key atrule">initialDelaySeconds</span><span class="token punctuation">:</span> <span class="token number">0  </span>       <span class="token comment" spellcheck="true"># 容器健康检查的探测等待响应超时时间设置, 单位为秒, 超过该时间, 将重启容器</span>       <span class="token key atrule">timeoutSeconds</span><span class="token punctuation">:</span> <span class="token number">0   </span>       <span class="token comment" spellcheck="true"># 容器健康检查的定期探测时间设置, 单位为秒, 默认10秒探测一次</span>       <span class="token key atrule">periodSeconds</span><span class="token punctuation">:</span> <span class="token number">0    </span>       <span class="token comment" spellcheck="true"># 失败后最少成功几次才会认为容器健康, 最小为1</span>       <span class="token key atrule">successThreshold</span><span class="token punctuation">:</span> <span class="token number">0</span>       <span class="token comment" spellcheck="true"># 失败多少次后才会重启容器, 默认为3, 最小为1</span>       <span class="token key atrule">failureThreshold</span><span class="token punctuation">:</span> <span class="token number">0</span>       <span class="token comment" spellcheck="true"># pod的安全设置</span>       <span class="token key atrule">securityContext</span><span class="token punctuation">:</span>         privileged<span class="token punctuation">:</span><span class="token boolean important">false</span>    <span class="token comment" spellcheck="true"># 重启策略。Always(Pod一旦终止运行, kubelet将会重启它)、OnFailure(非正常结束时, 才会重启该容器)</span>    <span class="token comment" spellcheck="true"># Never(Pod终止后, kubelet将退出码报告给Master, 不会再重启该Pod)</span>    <span class="token key atrule">restartPolicy</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 表示将Node调度到包含这些Label的Node上</span>    <span class="token key atrule">nodeSelector</span><span class="token punctuation">:</span> obeject      <span class="token comment" spellcheck="true"># pull镜像时, 使用的secret名称</span>    <span class="token key atrule">imagePullSecrets</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string    <span class="token comment" spellcheck="true"># 是否使用主机网络模式, 为true则使用宿主机网络, 不再使用Docker网桥</span>    hostNetwork<span class="token punctuation">:</span><span class="token boolean important">false     </span>    <span class="token comment" spellcheck="true"># 在该Pod上定义的共享存储卷列表</span>    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>             <span class="token comment" spellcheck="true"># 每个共享存储卷名称唯一</span>    <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> string       <span class="token comment" spellcheck="true"># 与Pod生命周期相同的一个临时目录</span>      <span class="token key atrule">emptyDir</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token comment" spellcheck="true"># 挂载在所在宿主机的目录</span>      <span class="token key atrule">hostPath</span><span class="token punctuation">:</span>              <span class="token key atrule">path</span><span class="token punctuation">:</span> string        <span class="token comment" spellcheck="true"># 挂载集群预定义的secret对象到容器内部  </span>      <span class="token key atrule">secret</span><span class="token punctuation">:</span>              <span class="token key atrule">scretname</span><span class="token punctuation">:</span> string          <span class="token key atrule">items</span><span class="token punctuation">:</span>             <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> string          <span class="token key atrule">path</span><span class="token punctuation">:</span> string      <span class="token comment" spellcheck="true"># 关在集群预定义的configMap到容器内部    </span>      <span class="token key atrule">configMap</span><span class="token punctuation">:</span>            <span class="token key atrule">name</span><span class="token punctuation">:</span> string        <span class="token key atrule">items</span><span class="token punctuation">:</span>        <span class="token punctuation">-</span> <span class="token key atrule">key</span><span class="token punctuation">:</span> string          <span class="token key atrule">path</span><span class="token punctuation">:</span> string</code></pre><p>属于一个Pod的多个容器应用之间相互访问仅需要通过localhost就可以通信, 使得这一组容器被绑定在一个环境中。</p><h3 id="静态Pod"><a href="#静态Pod" class="headerlink" title="静态Pod"></a>静态Pod</h3><p>其是由kubelet进行管理的仅存在于特定Node上的Pod, 不能通过API Server进行管理, 无法与ReplicationController、Deployment、DaemonSet进行关联, 并且kubelet无法对它们进行健康检查。</p><p>静态Pod总是由kubelet进行创建, 并且总是在kubelet所在的Node上运行。</p><p>创建静态Pod有两种方式: 配置文件或者HTTP方式。</p><h3 id="Pod的配置管理-ConfigMap"><a href="#Pod的配置管理-ConfigMap" class="headerlink" title="Pod的配置管理-ConfigMap"></a>Pod的配置管理-ConfigMap</h3><h4 id="典型用法"><a href="#典型用法" class="headerlink" title="典型用法"></a>典型用法</h4><ul><li>生成容器内的环境变量。</li><li>设置容器启动命令的启动参数(需设置为环境变量)。</li><li>以volume的形式挂载为容器内部的文件或目录。</li></ul><p>configmap以<code>key:value</code>的形式保存在kubernetes系统中供应用使用, 可以通过<code>yaml</code>或<code>kubectl create configmap</code>命令行的方式来创建ConfigMap。</p><pre class=" language-shell"><code class="language-shell">kubectl create -f cm-appvars.yamlkubectl create configmap NAME --from-file=config-files-dir --from-literal=</code></pre><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li><p>通过环境变量获取ConfigMap中的内容。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">...</span><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>test    <span class="token key atrule">env</span><span class="token punctuation">:</span>    <span class="token punctuation">-</span><span class="token key atrule">-name</span><span class="token punctuation">:</span> APPLOGLEVEL      <span class="token key atrule">valueFrom</span><span class="token punctuation">:</span>        <span class="token key atrule">configMapKeyRef</span><span class="token punctuation">:</span>          <span class="token key atrule">name</span><span class="token punctuation">:</span> cm<span class="token punctuation">-</span>appvars          <span class="token key atrule">value</span><span class="token punctuation">:</span> apploglevel    <span class="token punctuation">...</span></code></pre></li></ul><ul><li>通过Volume挂载的方式将ConfigMap中的内容挂载为容器内部的文件或目录。</li></ul><h4 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h4><ul><li>ConfigMap必须在Pod之前创建。</li><li>ConfigMap也可以定义为属于某个namespace, 只有处于相同namespace中的Pod可以引用它。</li><li>静态Node无法引用ConfigMap。</li></ul><h3 id="生命周期和重启策略"><a href="#生命周期和重启策略" class="headerlink" title="生命周期和重启策略"></a>生命周期和重启策略</h3><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>Pending</td><td>API Server已创建该Pod, 但Pod内还有一个或多个容器没有创建, 包括正在下载镜像的过程。</td></tr><tr><td>Running</td><td>Pod内所有容器均已创建, 且至少有一个容器处于运行状态、正在启动状态或正在重启状态。</td></tr><tr><td>Succeeded</td><td>Pod内所有容器均成功执行退出, 且不会再重启。</td></tr><tr><td>Failed</td><td>Pod内所有容器均已退出, 但至少有一个容器退出为失败状态。</td></tr><tr><td>Unknown</td><td>由于某种原因无法获取该Pod的状态, 可能由于网络通信不畅导致。</td></tr></tbody></table><h4 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h4><p>Pod的重启策略(RestartPolicy)应用于Pod内的所有容器, 并且仅在Pod所处的Node上由<code>kubelet</code>进行判断和重启操作。</p><ul><li>Always: 当容器失效时, 有kubelet自动重启该容器。</li><li>OnFailure:  当容器终止运行且退出码不为0时, 由kubelet自动重启该容器。</li><li>Never: 不论容器运行状态如何, kubelet都不会重启该容器。</li></ul><p>kubelet重启失效容器的时间间隔以sync-frequency乘以2n来计算, 最长延时5分钟, 并且在成功重启后10分钟后重置该时间。</p><p>Pod的重启策略与控制方式息息相关。</p><ul><li>RC和DaemonSet: 必须设置为Always, 需要保证该容器持续运行。</li><li>Job: OnFailure或Never, 确保容器执行完成后不再重启。</li><li>kubelet管理的静态Pod: 在Pod失效时自动重启它。</li></ul><h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>可以通过两类探针来检查: LivenessProbe和ReadinessProbe。</p><ul><li><p>LivenessProbe: 用于判断容器是否存活, 当不包含时, 默认返回值永远是”Success”。</p><p>有以下三种实现方式。</p><ul><li>ExecAction: 在容器内部执行一个命令, 如果该命令返回码为0, 则表明容器健康。</li><li>TCPSocketAction: 通过容器的IP地址和端口号执行TCP检查, 如果能建立TCP连接, 则表明容器健康。</li><li>HTTPGetAction: 调用HTTP Get方法, 如果响应码大于等于200且小于等于400, 则认为容器健康。</li></ul></li><li><p>ReadinessProbe: 用于判断容器是否启动完成, 可以接受请求。如果检测到失败, <code>Endpoint Controller</code>将从Service的Endpoint找那个删除该容器所在Pod的Endpoint。</p></li></ul><p>对于每种探测方式, 都需要设置initialDelaySeconds和timeoutSeconds两个参数。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>Master上的Scheduler服务负责实现Pod的调度。</p><h4 id="NodeSelector-定向调度"><a href="#NodeSelector-定向调度" class="headerlink" title="NodeSelector: 定向调度"></a>NodeSelector: 定向调度</h4><p>通过Node的标签和Pod的<code>nodeSelector</code>属性相匹配, 来达到上述目的。</p><p>如果指定了Pod的nodeSelector, 且集群中不存在包含相应标签的Node, 则即使集群中还有其他可供使用的Node, 这个Pod也无法被成功调度。</p><h4 id="NodeAffinity-亲和性调度"><a href="#NodeAffinity-亲和性调度" class="headerlink" title="NodeAffinity: 亲和性调度"></a>NodeAffinity: 亲和性调度</h4><p>替换NodeSelector的下一代调度策略。</p><p>NodeAffinity增加了In、NotIn、Exiss、DoesNotExist、Gt、Lt等操作符来选择Node, 能够使调度策略更加灵活。</p><p>如果同时设置了NodeSelector和NodeAffinity, 则系统将需要同时满足两者的设置才能进行调度。</p><h4 id="DaemonSet-特定场景调度"><a href="#DaemonSet-特定场景调度" class="headerlink" title="DaemonSet: 特定场景调度"></a>DaemonSet: 特定场景调度</h4><p>用于管理集群中每个Node上仅运行一份Pod的副本实例。</p><ul><li>在每个Node上运行一个GlusterFS存储或Ceph存储的daemon进程。</li><li>在每个Node上运行一个日志采集程序, 如fluentd或logstach。</li><li>在每个Node上运行一个健康程序, 采集该Node的运行性能数据。</li></ul><p>也可以在<code>DaemonSet</code>的yaml中使用NodeSelector或NodeAffinity来指定满足条件的Node范围进行调度。</p><h4 id="Job-批处理调度"><a href="#Job-批处理调度" class="headerlink" title="Job: 批处理调度"></a>Job: 批处理调度</h4><ul><li>Job Template Expansion模式: 一个Job对象对应一个待处理的Work item。</li><li>Queue with Pod Per Work Item模式: 采用一个队列存放Work Item, 一个Job作为消费者去完成这些Work Item, 在这种某事下, Job启动N个Pod, 每个Pod对应一个Work Item。</li><li>Queue with Variable Pod Count模式: 与上面模式不同的是, Job启动的Pod数量是可变的。</li></ul><h3 id="扩容和缩容"><a href="#扩容和缩容" class="headerlink" title="扩容和缩容"></a>扩容和缩容</h3><ul><li><p>通过rc的scale机制来完成这些工作。</p><pre class=" language-shell"><code class="language-shell">kubectl scale rc redis --replicas= 3</code></pre></li><li><p>使用HPA(HorizontalPodAutoscaler)。</p></li></ul><h3 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h3><p>使用rolling-update命令。</p><pre class=" language-shell"><code class="language-shell">kubectl rolling-update redis -f redis-controller-v2.yamlkubectl rolling-update redis --image=redis-master:2.0</code></pre><p>定义v2版本的ReplicationController.yaml时需注意。</p><ul><li>RC的name不能与旧的RC名字相同。</li><li>在selector中至少有一个Label应与旧的不同, 以便区分。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes之kubectl</title>
      <link href="/2019/12/13/kubernetes-zhi-kubectl/"/>
      <url>/2019/12/13/kubernetes-zhi-kubectl/</url>
      
        <content type="html"><![CDATA[<h3 id="命令行语法"><a href="#命令行语法" class="headerlink" title="命令行语法"></a>命令行语法</h3><pre class=" language-shell"><code class="language-shell">kubectl [command] [TYPE] [NAME] [flags]</code></pre><ul><li><p>command: 子命令, 用于操作kubernetes集群资源对象的命令, 如create、delete、describe、get、apply等。</p></li><li><p>TYPE: 资源对象的类型, 区分大小写, 能以单数形式、复数形式或简写形式表示。</p></li><li><p>NAME: 资源对象的名称, 区分大小写, 如果不指定名称, 则将返回属于TYPE的全部对象的列表。</p></li><li><p>flags: kubectl子命令的可选参数。如<code>kubectl -s http://localhost:8081</code>， 指定apiserver的URL地址而不使用默认值。</p></li><li><p>在一个命令行中也可以同时对多个资源对象进行操作。</p><ul><li><p>获取多个pod的信息。</p><pre class=" language-shell"><code class="language-shell">kubectl get pods pod1 pod2</code></pre></li><li><p>获取多种对象的信息。</p><pre class=" language-shell"><code class="language-shell">kubectl get pod/pod1 rc/rc1</code></pre></li><li><p>同时应用多个yaml文件, 以-f file参数表示。</p><pre class=" language-shell"><code class="language-shell">kubectl get pod -f pod1.yaml -f pod2.yamlkubectl create -f pod1.yaml -f rc1.yaml</code></pre></li></ul></li><li><p>可使用<code>kubectl --help</code>查看kubectl命令行公共启动参数及支持的子命令, 每个子命令还有特定的flags参数, 可通过<code>kubectl [command] --help</code>命令进行查看。</p></li></ul><h3 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h3><ul><li><p>根据yaml文件一次性创建service和rc。</p><pre class=" language-shell"><code class="language-shell">kubectl create -f my-service.yaml -f my-rc.yaml</code></pre></li><li><p>查看rc和service列表。</p><pre class=" language-shell"><code class="language-shell">kubectl get rc,service</code></pre></li><li><p>描述资源对象。</p><pre class=" language-shell"><code class="language-shell">kubectl describle nodes <node-name></code></pre></li><li><p>删除资源对象。</p><pre class=" language-shell"><code class="language-shell">kubectl delete -f pod.yaml# 删除所有包含label的pod和servicekubectl delete pods, services -l name=<label-name># 删除所有podkubectl delete pods --all</code></pre></li><li><p>执行容器的命令。</p><pre class=" language-shell"><code class="language-shell">kubectl exec <pod-name> -c <container-name> date# 登录容器kubectl exec -it <pod-name> -c <container-name> /bin/bash</code></pre></li><li><p>查看容器的日志。</p><pre class=" language-shell"><code class="language-shell">kubectl logs <pod-name># tailf-fkubectl logs -f <pod-name> -c <container-name></code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes之安装与配置</title>
      <link href="/2019/12/11/kubernetes-zhi-an-zhuang-yu-pei-zhi/"/>
      <url>/2019/12/11/kubernetes-zhi-an-zhuang-yu-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>本文为观看<code>Kubernetes权威指南-第二版.pdf</code>第二章的笔记。</p><h3 id="简单的安装方式"><a href="#简单的安装方式" class="headerlink" title="简单的安装方式"></a>简单的安装方式</h3><p>最简单的安装方式, 仍需修改各组件的启动参数, 才能完成kubernetes集群的配置。</p><ol><li><p>安装etcd和kubernetes。</p><pre class=" language-shell"><code class="language-shell">yum install -y etcd kubernetes</code></pre></li><li><p>修改配置文件。</p><pre class=" language-shell"><code class="language-shell"># 将OPTIONS的内容设置为'--selinux-enabled=false --insecure-registry gcr.io'vim /etc/sysconfig/docker# 把--admission_control参数中的ServiceAccount删除vim /etc/kubernetes/apiserver</code></pre></li><li><p>按顺序启动所有服务。</p><pre class=" language-shell"><code class="language-shell">systemctl start etcdsystemctl start dockersystemctl start kube-apiserversystemctl start kube-controller-managersystemctl start kube-schedulersystemctl start kubeletsystemctl start kube-proxy</code></pre></li><li><p>至此单机版的kubernetes搭建完成。</p></li></ol><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul><li><p>apiserver端口占用？</p><p>默认为8080。</p><p>修改<code>/etc/kubernetes/apiserver</code>里的配置<code>KUBE_API_PORT</code>。</p><p>同时修改<code>kubectl</code>的映射<code>alias kubectl='kubectl -s http://localhost:8081'</code>。</p></li></ul><h3 id="通过二进制文件和手动配置启动参数安装"><a href="#通过二进制文件和手动配置启动参数安装" class="headerlink" title="通过二进制文件和手动配置启动参数安装"></a>通过二进制文件和手动配置启动参数安装</h3><p>下载地址为<a href="https://github.com/kubernetes/kubernetes/releases/download/v1.3.0/kubernetes.tar.gz" target="_blank" rel="noopener">kubernetes-v1.3.0</a>, 解压后, server子目录中<code>kubernetes-server-linux-amd64.tar.gz</code>包含了kubernetes需要运行的全部服务程序文件。</p><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><h5 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h5><ul><li><p>下载etcd, 使用版本为3.0.0</p><pre class=" language-shell"><code class="language-shell">curl -L https://github.com/coreos/etcd/releases/download/v3.0.0/etcd-v3.0.0-linux-amd64.tar.gz -o etcd-v3.0.0-linux-amd64.tar.gz</code></pre></li><li><p>将<code>etcd</code>、<code>etcdctl</code>复制到<code>/usr/bin</code>目录下。</p></li><li><p>设置<code>systemd</code>服务文件<code>/usr/lib/systemd/system/etcd.service</code>。</p><p>WorkingDirectory为etcd数据保存的目录, 需要在启动etcd服务之前进行创建。</p><pre><code>[Unit]Description=Etcd ServerAfter=network.target[Service]Type=simpleWorkingDirectory=/var/lib/etcd/EnvironmentFile=-/etc/etcd/etcd.confExecStart=/usr/bin/etcd[Install]WantedBy=multi-user.target</code></pre></li><li><p>通过<code>systemctl start</code>命令启动etcd服务。</p><pre class=" language-shell"><code class="language-shell">systemctl daemon-reloadsystemctl enable etcd.servicesystemctl start etcd.service</code></pre></li><li><p>通过执行<code>etcdctl cluster-health</code>, 可以验证etcd是否正确启动。</p></li></ul><h5 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h5><ul><li><p>拷贝<code>kube-apiserver</code>复制到<code>/usr/bin</code>目录。</p></li><li><p>设置<code>systemd</code>服务文件<code>/usr/lib/systemd/system/kube-apiserver.service</code>。</p><pre><code>[Unit]Description=Kubernetes API ServerDocumentation=https://github.com/kubernetes/kubernetesAfter=etcd.serviceWants=etcd.service[Service]EnvironmentFile=/etc/kubernetes/apiserverExecStart=/usr/bin/kube-apiserver $KUBE_API_ARGSRestart=on-failureType=notifyLimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre></li><li><p>在配置文件<code>/etc/kubernetes/apiserver</code>中配置<code>kube-apiserver</code>的启动参数。</p><pre><code>KUBE_API_ARGS="--etcd_servers=http://127.0.0.1:2379                --insecure-bind-address=0.0.0.0               --insecure-port=8081                --service-cluster-ip-range=169.169.0.0/16               --service-node-port-range=1-65535--admission_control=NamespaceLifecycle,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota               --logtostderr=false                --log-dir=/var/log/kubernetes                --v=2" </code></pre><ul><li>–etcd_servers: etcd服务的url。</li><li>–service-cluster-ip-range: kubernetes集群中Service虚拟IP地址段范围, 以CIDR格式表示, 该IP范围不能与物理机的真实IP段有重合。</li><li>–service-node-port-range: kubernetes集群中Service可映射的物理机端口号范围, 默认为30000~32767</li><li>–admission_control: kubernetes集群的准入控制设置, 各控制模块以插件的形式依次生效。</li><li>–logtostderr: 设置为false表示将日志写入文件, 不写入stderr。</li><li>–log-dir: 日志目录。</li><li>–v: 日志级别。</li></ul></li></ul><h5 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h5><ul><li><p>拷贝<code>kube-controller-manager</code>复制到<code>/usr/bin</code>目录。</p></li><li><p>设置<code>systemd</code>服务文件<code>/usr/lib/systemd/system/kube-controller-manager.service</code>。</p><pre><code>[Unit]Description=Kubernetes Controller ManagerDocumentation=https://github.com/kubernetes/kubernetesAfter=kube-apiserver.serviceRequires=kube-apiserver.service[Service]EnvironmentFile=/etc/kubernetes/controller-managerExecStart=/usr/bin/kube-controller-manager $KUBE_CONTROLLER_MANAGER_ARGSRestart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre></li><li><p>在配置文件<code>/etc/kubernetes/controller-manager</code>中配置<code>kube-controller-manager</code>的启动参数。</p><pre><code>KUBE_CONTROLLER_MANAGER_ARGS="--master=http://127.0.0.1:8081 --logtostderr=false --log-dir=/var/log/kubernetes --v=2"</code></pre></li></ul><h5 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h5><ul><li><p>拷贝<code>kube-scheduler</code>复制到<code>/usr/bin</code>目录。</p></li><li><p>设置<code>systemd</code>服务文件<code>/usr/lib/systemd/system/kube-scheduler.service</code>。</p><pre><code>[Unit]Description=Kubernetes SchedulerDocumentation=https://github.com/kubernetes/kubernetesAfter=kube-apiserver.serviceRequires=kube-apiserver.service[Service]EnvironmentFile=/etc/kubernetes/schedulerExecStart=/usr/bin/kube-scheduler $KUBE_SCHEDULER_ARGSRestart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre></li><li><p>在配置文件<code>/etc/kubernetes/scheduler</code>中配置<code>kube-scheduler</code>的启动参数。</p><pre><code>KUBE_SCHEDULER_ARGS="--master=http://127.0.0.1:8081 --logtostderr=false --log-dir=/var/log/kubernetes --v=2"</code></pre></li></ul><h5 id="start"><a href="#start" class="headerlink" title="start"></a>start</h5><ul><li><p>通过<code>systemctl start</code>命令启动以上三个服务。</p><pre><code>systemctl daemon-reloadsystemctl enable &lt;service_name&gt;systemctl start &lt;service_name&gt;</code></pre></li><li><p>通过<code>systemctl status &lt;service_name&gt;</code>来验证服务的启动状态, <code>running</code>表示启动成功。</p></li><li><p>将<code>kubectl</code>复制到<code>/usr/bin</code>目录。</p></li><li><p>到此, Master上所需的服务就全部启动完成了。</p></li></ul><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>在Node节点上需要预先安装好Docker Daemon并且正常启动。</p><h5 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h5><p>kubelet服务依赖于Docker服务。</p><ul><li><p>拷贝<code>kubelet</code>复制到<code>/usr/bin</code>目录。</p></li><li><p>设置<code>systemd</code>服务文件<code>/usr/lib/systemd/system/kubelet.service</code>。</p><pre><code>[Unit]Description=Kubernetes Kubelet ServerDocumentation=https://github.com/kubernetes/kubernetesAfter=docker.serviceRequires=docker.service[Service]WorkingDirectory=/var/lib/kubeletEnvironmentFile=/etc/kubernetes/kubeletExecStart=/usr/bin/kubelet $KUBELET_ARGSRestart=on-failure[Install]WantedBy=multi-user.target</code></pre></li><li><p>在配置文件<code>/var/lib/kubelet</code>中配置<code>kubelet</code>的启动参数。</p><pre><code>KUBELET_ARGS="--api-servers=http://127.0.0.1:8081 --hostname-override=127.0.0.1 --logtostderr=false --log-dir=/var/log/kubernetes --v=2"</code></pre></li></ul><h5 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h5><p>kube-proxy服务依赖于network服务。</p><ul><li><p>拷贝<code>kube-proxy</code>复制到<code>/usr/bin</code>目录。</p></li><li><p>设置<code>systemd</code>服务文件<code>/usr/lib/systemd/system/kube-proxy.service</code>。</p><pre><code>[Unit]Description=Kubernetes Kube-Proxy ServerDocumentation=https://github.com/kubernetes/kubernetesAfter=network.targetRequires=network.service[Service]EnvironmentFile=/etc/kubernetes/proxyExecStart=/usr/bin/kube-proxy $KUBE_PROXY_ARGSRestart=on-failureLimitNOFILE=65536[Install]WantedBy=multi-user.target</code></pre></li><li><p>在配置文件<code>/etc/kubernetes/proxy</code>中配置<code>kube-proxy</code>的启动参数。</p><pre><code>KUBE_PROXY_ARGS="--master=http://127.0.0.1:8081 --logtostderr=false --log-dir=/var/log/kubernetes --v=2"</code></pre></li></ul><h5 id="LAST"><a href="#LAST" class="headerlink" title="LAST"></a>LAST</h5><p>参考<a href="#start" target="_self">start</a>启动kubelet和kube-proxy服务。</p><p>因端口使用的不是默认的8080, 执行<code>alias kubectl='kubectl -s http://localhost:8081'</code>。</p><p>因为kubelet默认采用想Master自动注册本Node的机制, 可直接查看Node的状态, 状态为Ready表示Node已经成功注册并且状态为可用。</p><pre class=" language-shell"><code class="language-shell">kubectl get nodes</code></pre><h4 id="Q-amp-A-1"><a href="#Q-amp-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ol><li><p>出现问题, 非预期表现。</p><p>使用<code>journalctl -xe</code>查看详细报错信息, 针对性解决。</p></li><li></li></ol><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li><p>仍需关注的点包括安全设置, 其支持<code>基于CA签名的数字证书认证方式</code>和<code>基于HTTP BASE或TOKEN的简单认证方式</code>。</p></li><li><p>在多个Node组成的Kubernetes集群内, 跨主机的容器间网络互通式Kubernetes集群能够正常工作的前提条件。Kubernetes本身并不会对跨主机网络进行设置, 这需要额外的工具来实现, 开源工具包括flannel、Open vSwitch、Weave、Calico等都能够实现跨主机的容器间网络互通。</p><p>也可以通过在每个Node上添加其他Node上的docker0的静态路由规则, 将不同物理机的docker0网桥互联互通。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubernetes之初入门</title>
      <link href="/2019/12/04/kubernetes-zhi-chu-ru-men/"/>
      <url>/2019/12/04/kubernetes-zhi-chu-ru-men/</url>
      
        <content type="html"><![CDATA[<p>本文为观看<code>Kubernetes权威指南-第二版.pdf</code>第一章的笔记, 主要是k8s的核心概念。</p><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>给<code>pod</code>(其中运行了服务进程容器)贴上<code>label</code>(标签), 然后给相应的Service定义Label Selector(标签选择器), 这样就将service和pod关联了起来。</p><p>pod运行在node(节点)的环境中, 通常在一个node中运行几百个pod。</p><p>每个pod里运行一个pause容器, 其他为业务容器。所有业务容器共享pause容器的网络栈和volume挂载卷。</p><p>在集群管理方面, Kubernetes将集群中的机器划分为一个Master节点和一群工作节点(Node)。</p><ul><li>Master节点上运行着集群管理相关的一组进程kube-apiserver、kube-controller-manager和kube-scheduler,这些进程实现了整个集群的资源管理、Pod调度、弹性伸缩、安全控制、系统监控和纠错管理等功能。</li><li>Node作为集群中的工作节点, 运行真正的应用程序。 在Node上运行kubelet、kube-proxy服务进程, 负责Pod的创建、启动、监控、重启、销毁, 以及实现负载均衡器。</li></ul><h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><p>k8s中大部分概念如Node、Pod、Replication Controller、Service等都可以看作一种资源对象, 几乎所有对象都可以通过<code>kubectl</code>或<code>API编程调用</code>, 来进行增删查改并将其保存在etcd中持久化存储。</p><p>kubernetes是一个高度自动化的资源控制系统, 它通过跟踪对比etcd库里保存的<code>资源期望状态</code>与<code>实际资源状态</code>的差异来实现自动控制和自动纠错的高级功能。</p><h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p>Master指的是集群控制节点, 负责整个集群的管理和控制。</p><p>基本上所有k8s的控制命令都是发给Master, 由其负责具体的执行过程。</p><p>Master节点运行如下一组关键进程。</p><ul><li>Kubernetes API Server(kube-apiserver), 提供HTTP Rest接口的关键服务进程, 是所有资源增删查改操作的唯一入口, 也是集群控制的入口进程。</li><li>Kubernetes Controller Manager(kube-controller-manager), Kubernetes里所有资源对象的自动化控制中心。</li><li>Kubernetes Scheduler(kube-scheduler), 负责资源调度(Pod调度)的进程。</li><li>etcd Server进程, 所有资源对象的数据全部是保存在etcd中的。</li></ul><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>Node是k8s集群中的工作负载节点, 每个Node节点都会被Master分配一些工作负载, 当某个Node宕机时, 其上的工作负载会被转移到其他Node节点上去。</p><p>每个Node节点上运行着以下一组关键进程: </p><ul><li>kubelet: 负责对Pod对应的容器的创建、启停等任务, 同时与Master节点密切协作, 实现集群管理的基本功能。</li><li>kube-proxy: 实现Kubernetes Service的通信与负载均衡机制的重要组件。</li><li>Docker Engine: Docker引擎, 负责容器的创建和管理工作。</li></ul><p>Node可以在运行期间动态增加到Kubernetes集群中, 前提是上述关键进程咦正确安装、配置和启动。</p><p>kubelet会定时向Master节点上报自身的情况, 当超过指定时间未上报时, Master会判定其为失联, 进而出发工作负载的转移。</p><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><p>Pod包含Pause容器及一个或多个紧密相关的用户业务容器。</p><p>Pod分为普通的Pod及静态Pod, 静态Pod的不同之处在于, 它并不存放在k8s的etcd存储里, 而是存放在某一具体文件中, 并只在此Node上启动运行。</p><ul><li><p>Pause容器作为Pod的根容器, 它的状态代表了整个容器组的状态。</p></li><li><p>多个业务容器共享Pause容器的IP及其挂接的Volume。</p></li><li><p>k8s的底层网络支持集群内任意两个Pod之间的TCP/IP直接通信(采用虚拟二层网络技术实现), 故一个Pod里的容器能与另外主机上的Pod容器直接通信。</p></li><li><p>pod volume, 定义在Pod之上, 然后被各容器挂载到自己的文件系统中的。</p></li><li><p>Event, 一个事件的记录, 记录事件的最早产生事件、 最后重现事件、重复次数等众多信息, 是排查故障的重要参考信息。</p><pre class=" language-shell"><code class="language-shell">kubectl describe pod XXX</code></pre></li><li><p>每个Pod都可以对其能使用的服务器上的计算资源设置限额, 当前可设置的包括CPU和memory。</p><ol><li><p><font color="red">CPU的资源单位数量是绝对值</font>，以千分之一的CPU配额为最小单位, 用m标识。</p><p>即100m这个配额所代表的CPU使用量, 在48个core的机器上与1个core的机器上的CPU使用量是一样的。</p></li><li><p>Memory的配额也是一个绝对值, 它的单位是内存字节数。</p><p>在kubernetes中, 一个计算资源进行配额限定需设定以下两个参数。</p></li></ol><ul><li><p>Requests: 该资源最小申请量, 系统必须满足的需求。</p></li><li><p>Limits: 该资源最大允许使用量, 不能被突破, 当超过时, 可能会被kill并重启。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">containers</span><span class="token punctuation">:</span>    <span class="token key atrule">resources</span><span class="token punctuation">:</span>      <span class="token key atrule">requests</span><span class="token punctuation">:</span>        <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"64Mi"</span>        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"250m"</span>      <span class="token key atrule">limits</span><span class="token punctuation">:</span>         <span class="token key atrule">memory</span><span class="token punctuation">:</span> <span class="token string">"128Mi"</span>        <span class="token key atrule">cpu</span><span class="token punctuation">:</span> <span class="token string">"500m"</span></code></pre></li></ul></li></ul><h4 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h4><p>一个Label是一个key=value的键值对, 其中key和value由用户自己指定。</p><p>Label可以附加到各种资源上, 例如Node、Pod、Service、RC等。</p><p>一个资源对象可以定义任意数量的Label, 同一个Label也可以被添加到任意数量的资源对象上去。</p><p>Label可以在资源对象被定义时确定, 也可以在对象创建后动态添加或者删除。</p><h5 id="Label-Selector"><a href="#Label-Selector" class="headerlink" title="Label Selector"></a>Label Selector</h5><p>Label Selector作用于Pod时, 可以被类比为<code>select * from pod where pod's name = 'redis-slave'</code>这样的语句。</p><p>当前有两种label Selector表达式, 基于等式(Equality-based)和基于集合(Set-based)的。</p><ul><li><p>name=redis-slave或env!=production。</p></li><li><p>name in (redis-master, redis-slave)或name not in (php-frontend)。</p></li><li><p>多个表达式之间用<code>,</code>分割, 几个条件之间是<code>AND</code>的关系, 即同时满足多个条件。</p><pre class=" language-sql"><code class="language-sql">name<span class="token operator">=</span>redis<span class="token operator">-</span>slave<span class="token punctuation">,</span> name <span class="token operator">not</span> <span class="token operator">in</span> <span class="token punctuation">(</span>php<span class="token operator">-</span>fronted<span class="token punctuation">)</span></code></pre></li></ul><p>label selector的使用场景如下:</p><ul><li><code>kube-controller</code>进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod副本的数量, 从而实现Pod副本的数量始终符合预期设定的全自动控制流程。</li><li><code>kube-proxy</code>进程通过Service的Label Selector来选择对应的Pod, 自动建立起每个Service到Pod的请求转发路由表, 从而实现Service的智能负载均衡机制。</li><li>通过对某些Node定义特定的Label, 并在Pod定义文件中使用NodeSelector这种标签调度策略, <code>kube-selector</code>进程可实现Pod<code>定向调度</code>的特性。</li></ul><h4 id="Replication-Controller-RC"><a href="#Replication-Controller-RC" class="headerlink" title="Replication Controller(RC)"></a>Replication Controller(RC)</h4><p>RC定义了一个期望的场景, 即声明某种Pod的副本数量在任何时刻都符合某个期望值, 其定义包括如下几个部分。</p><ul><li>Pod期待的副本数(replicas)。</li><li>用于筛选目标Pod的Label Selector。</li><li>当目标的副本数量小于预期数量时, 用于创建Pod的Pod模板。</li></ul><p>Master节点的Controller Manager会定期巡检系统中存活的目标Pod, 确保其数量刚好等于此RC的期望值。</p><p>可以修改RC的副本数量, 来实现Pod的动态缩放(Scaling), 或通过<code>kubectl scale</code>命令来完成。</p><pre class=" language-shell"><code class="language-shell">kubectl scale rc redis-slave --replicas=3</code></pre><p>下一代的RC: <code>Replica Set</code>。</p><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><p>kubernetes 1.2引入的新概念, 为了更好的解决Pod的编排问题, 其内部使用了Replica Set来实现目的。</p><h4 id="HPA-Horizontal-Pod-Autoscaler"><a href="#HPA-Horizontal-Pod-Autoscaler" class="headerlink" title="HPA(Horizontal Pod Autoscaler)"></a>HPA(Horizontal Pod Autoscaler)</h4><p>HPA指Pod横向自动扩容, 其通过追踪分析RC控制的所有目标Pod的负载变化情况, 来确定是否需要针对性地调整目标Pod的副本数。</p><p>HPA包括的负载的度量指标有:</p><ul><li>CPUUtilizationPercentage, 此是目标Pod所有副本自身的CPU利用率的平均值。一个Pod自身的CPU利用率是该Pod当前CPU使用量除以它的Pod Request的值。</li><li>应用程序自定义的度量指标(TPS或QPS)。</li></ul><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>service可理解为微服务架构中的一个”微服务”, 其通过<code>Label Selector</code>与Pod紧密结合在一起。</p><p>每个Service分配了一个全局唯一的虚拟Ip地址, 即CLuster IP。在Service的整个生命周期内, 它的Cluster IP不会发生改变。</p><h4 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h4><p>存储卷, 定义在Pod上, 与Pod的生命周期相同。</p><h4 id="Persistent-Volume"><a href="#Persistent-Volume" class="headerlink" title="Persistent Volume"></a>Persistent Volume</h4><p>PV是网络存储, 不属于任何Node, 但可以在每个Node上访问。</p><p>某个Pod想申请某种条件的PV, 首先需定义一个PersistentVolumeClaim(PVC), 然后在Pod的Volume定义中引用上述PVC即可。</p><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><p>用于实现多租户的资源隔离, 属于逻辑隔离, 不同的分组可以共享整个集群的资源。</p><h4 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h4><p>定义用户任意定义的附加信息, 以便于外部工具进行查找。 </p><h4 id="k8s里的三种”ip”"><a href="#k8s里的三种”ip”" class="headerlink" title="k8s里的三种”ip”"></a>k8s里的三种”ip”</h4><ul><li><p>Node IP: Node节点的IP地址。</p><p>其是k8s集群中每个节点的物理网卡的IP地址, 这是一个真实存在的物理网络, 所有属于这个网络的服务器之间都能通过这个网络直接通信, 不管它们是否属于k8s集群。</p></li><li><p>Pod IP: Pod的IP地址。</p><p>它是Docker Engine根据docker0网桥的IP地址段进行分配的, 通常是一个虚拟的二层网络。</p><p>真实的TCP/IP流量是通过Node IP所在的物理网卡流出的。</p></li><li><p>Cluster IP: Service的IP地址。</p><p>Cluster IP仅作用于Kubernetes Service这个对象, 并由Kubernetes管理和分配IP地址(来源于Cluster IP地址池), 无法直接在集群外部使用这个地址。</p></li></ul><p>在kubernetes集群内, Node IP网、Pod IP网与Cluster IP网之间的通信, 采用的是Kubernetes自己设计的一种编程方式的特殊的路由规则。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos安装问题</title>
      <link href="/2019/12/04/centos-an-zhuang-wen-ti/"/>
      <url>/2019/12/04/centos-an-zhuang-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="centos安装问题"><a href="#centos安装问题" class="headerlink" title="centos安装问题"></a>centos安装问题</h3><h4 id="dracut-initqueue-timeout"><a href="#dracut-initqueue-timeout" class="headerlink" title="dracut_initqueue timeout"></a>dracut_initqueue timeout</h4><p>原因是UltroISO在Window下写入U盘的安装文件路径，没有被linux安装程序识别。</p><p>在U盘启动界面，根据提示，按tab/e键，修改系统引导命令行，修改为：</p><p>vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4 quiet</p><p>这sdb4的值是默认值，可能会不同</p><p><a href="https://www.cnblogs.com/zhangtingzu/p/8972063.html" target="_blank" rel="noopener">U盘启动安装CentOS 7和遇到错误</a></p><h4 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h4><p>安装后未能连接网络，因未开启网络连接。</p><p>修改网卡配置文件，把网络连接打开。</p><p>将etc/sysconfig/network-scripts/目录下的配置文件，将ONBOOT改为yes，然后service network restart。</p><p><a href="https://blog.csdn.net/sfeng95/article/details/62239539" target="_blank" rel="noopener">开启网络连接</a></p><h4 id="关闭报警声音"><a href="#关闭报警声音" class="headerlink" title="关闭报警声音"></a>关闭报警声音</h4><p>编辑/etc/inputrc，找到 #set bell-style none项，去掉注释。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-submodule</title>
      <link href="/2019/12/04/git-submodule/"/>
      <url>/2019/12/04/git-submodule/</url>
      
        <content type="html"><![CDATA[<h3 id="SYNOPSIS"><a href="#SYNOPSIS" class="headerlink" title="SYNOPSIS"></a>SYNOPSIS</h3><pre class=" language-shell"><code class="language-shell">.gitmodules, $GIT_DIR/config</code></pre><pre class=" language-shell"><code class="language-shell">git submodulegit <command> --recurse-submodules</code></pre><pre class=" language-shell"><code class="language-shell"># 同时克隆a项目的子模块git clone --recursive a.git</code></pre><h3 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION"></a>DESCRIPTION</h3><p>submodule是将一个repository内嵌在另一个repository中。</p><p>submodule有自己的提交历史, 其通常位于父项目的<code>$GIT_DIR/modules/</code>。</p><h3 id="Define-Submodule-Properties"><a href="#Define-Submodule-Properties" class="headerlink" title="Define Submodule Properties"></a>Define Submodule Properties</h3><p>使用.gitmodules文件进行定义, 其是一个文本文件, 位于<code>$GIT_WORK_DIR/.gitmodules</code>。</p><p>文件由每一个submodule组成, 每个submodule包含如下属性。</p><h4 id="必选参数"><a href="#必选参数" class="headerlink" title="必选参数"></a>必选参数</h4><ul><li>submodule.<name>.path: 指定submodule的相对路径, 不能以<code>/</code>结尾, 每个submodule路径是唯一的。</name></li><li>submodule.<name>.url: 指定submodule仓库地址, 可以是git地址或父项目的相对路径。</name></li></ul><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><ul><li><p>submodule.<name>.update: 指定submodule的更新策略, 包括checkout、rebase、merge、none, 只在<code>git submodule init</code>时生效。</name></p></li><li><p>submodule.<name>.branch: 指定git仓库的远程分支, 默认为master。特殊符号为<code>.</code>, 其标识分支名与父项目相同。</name></p></li><li><p>submodule.<name>.fetchRecurseSubmodules: 获取submodule的策略, 可被父项目中的配置覆盖或git fecth及git pull的参数<code>--[no-]recurse-submodules</code>覆盖。</name></p><pre><code>tips:git pull是git fetch及git merge FETCH_HEAD的缩写, 即执行git pull等同于执行git fetch和git merge FETCH_HEAD。</code></pre></li><li><p>submodule.<name>.ignore: 定义<code>git status</code>或<code>git diff</code>时是否展示submodule的修改, 支持的值为: all、dirty、untracked、 none。</name></p></li><li><p>submodule.<name>.shallow: 为true时表示为浅克隆, 即不会克隆历史记录。</name></p></li></ul><h4 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h4><pre class=" language-git"><code class="language-git">[submodule <span class="token string">"libfoo"</span>]    path = include/foo    url = git://foo.com/git/lib.git</code></pre><h3 id="command-line"><a href="#command-line" class="headerlink" title="command line"></a>command line</h3><pre class=" language-shell"><code class="language-shell"># add a submodulegit submodule add <url> <path></code></pre><pre class=" language-shell"><code class="language-shell"># See the list of submodules in a superprojectgit submodule status</code></pre><pre class=" language-shell"><code class="language-shell"># occasionally update the submodule to a new version:git -C <path> checkout <new version>git add <path>git commit -m "update submodule to new version"</code></pre><pre class=" language-shell"><code class="language-shell"># cloning missing submodules and updating the working tree of the submodulesgit submodule update --init --recursivegit submodule update --remote --merge</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>直接使用<code>git clone</code>不会同时下载submodule项目, 可使用<code>git clone --recursive</code>一并clone父项目与submodule项目; 或在父项目中使用<code>git submodule update</code>即可。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://yihui.org/cn/2017/03/git-submodule/" target="_blank" rel="noopener">GIT子模块</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven plugin介绍</title>
      <link href="/2019/12/02/maven-plugin-jie-shao/"/>
      <url>/2019/12/02/maven-plugin-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>介绍工作中用到的maven插件, 会时常补全。</p><h3 id="antrun-plugin"><a href="#antrun-plugin" class="headerlink" title="antrun plugin"></a>antrun plugin</h3><p><a href="http://maven.apache.org/plugins/maven-antrun-plugin/" target="_blank" rel="noopener">Apache Maven AntRun Plugin</a></p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>提供了运行ant task的能力,  帮助基于ant构建的项目进行迁移。</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span><span class="token punctuation">></span></span>  ...  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-antrun-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>                ...            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>      ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span>  ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="goals"><a href="#goals" class="headerlink" title="goals"></a>goals</h4><h4 id="antrun-help"><a href="#antrun-help" class="headerlink" title="antrun:help"></a>antrun:help</h4><p>展示maven-antrun-plugin的帮助信息。</p><pre class=" language-shell"><code class="language-shell"> mvn antrun:help -Ddetail=true -Dgoal=<goal-name></code></pre><ul><li>detail: 展示所有可配置的属性, 默认为false。</li><li>goal: 指定需展示的goal, 不指定时, 展示所有的goal。</li></ul><h4 id="antrun-run"><a href="#antrun-run" class="headerlink" title="antrun:run"></a>antrun:run</h4><p>Maven AntRun Mojo, 用来运行ant tasks, 最好将ant tasks放在build.xml中。</p><p><a href="http://maven.apache.org/plugins/maven-antrun-plugin/run-mojo.html" target="_blank" rel="noopener">antrun:run</a></p><h4 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h4><p>在target标签中定义行为,  否则将不会进行任何操作,  如下格式。</p><pre class=" language-xml"><code class="language-xml">... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- a lifecycle phase --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>             <span class="token comment" spellcheck="true">&lt;!--do something--></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>run<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>...</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>用来帮助ant项目的迁移。</p><p>通过phase指定在某个maven lifecycle执行target, 执行特定任务。</p><ul><li>可以用来将项目生成为自己想要的打包结构, 便于部署。</li></ul><pre class=" language-xml"><code class="language-xml">...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>copy-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>run<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>delete</span> <span class="token attr-name">dir</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${project.build.directory}/../docker<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>copy</span> <span class="token attr-name">todir</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{project.build.directory}/../docker/resource<span class="token punctuation">"</span></span>                        <span class="token attr-name">&lt;fileset</span> <span class="token attr-name">dir</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${project.build.outputDirectory}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>*.properties<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileset</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>copy</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>copy</span> <span class="token attr-name">file</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${project.build.directory}/${project.build.finalName}.jar<span class="token punctuation">"</span></span>             <span class="token attr-name">tofile</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${project.build.directory}/../docker/${project.build.finalName}.jar<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span></code></pre><ul><li><p>克隆git submodule。</p><pre class=" language-xml"><code class="language-xml">...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>validate<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>validate<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec</span> <span class="token attr-name">executable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>git<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submodule<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>update<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>--init<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>--recursive<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec</span> <span class="token attr-name">executable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>git<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submodule<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>update<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>--remote<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>run<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>...</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven小知识-classifier</title>
      <link href="/2019/12/02/maven-xiao-zhi-shi-classifier/"/>
      <url>/2019/12/02/maven-xiao-zhi-shi-classifier/</url>
      
        <content type="html"><![CDATA[<h4 id="classifier"><a href="#classifier" class="headerlink" title="classifier"></a>classifier</h4><p>classifier通常用于区分从同一POM构建的具有不同内容的构件（artifact）。它是可选的，它可以是任意的字符串，附加在版本号之后。</p><h5 id="区分基于不同JDK版本的jar包"><a href="#区分基于不同JDK版本的jar包" class="headerlink" title="区分基于不同JDK版本的jar包"></a>区分基于不同JDK版本的jar包</h5><p>如果项目依赖json-lib-2.2.2-jdk13.jar。则XML配置内容如下</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.sf.json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">></span></span>jdk13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  </code></pre><p>注意，如果json-lib没有提供，json-lib-2.2.2.jar。那么，设置依赖的时候，必须使用 classifier ，否则会报错，因为找不到指定的jar包。</p><h5 id="区分项目的不同组成部分"><a href="#区分项目的不同组成部分" class="headerlink" title="区分项目的不同组成部分"></a>区分项目的不同组成部分</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.sf.json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>json-lib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">></span></span>jdk15-javadoc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> </code></pre><p>即classifier中的内容附在版本号之后。</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://blog.csdn.net/qiumengchen12/article/details/71688395" target="_blank" rel="noopener">Maven中classifier</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客的搭建</title>
      <link href="/2019/11/27/hexo-bo-ke-de-da-jian/"/>
      <url>/2019/11/27/hexo-bo-ke-de-da-jian/</url>
      
        <content type="html"><![CDATA[<p>本文旨在讲述个人使用hexo及GithubPages搭建的过程。</p><p>主要参考<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析</a>。</p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>经对比, 选择<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>, demo为<a href="https://blinkfox.github.io/" target="_blank" rel="noopener">闪烁之狐</a>, 贼拉好看。</p><ul><li><p>下载主题至themes文件夹下, 然后修改<code>_config.yml</code>的theme字段为主题文件夹名称。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">theme</span><span class="token punctuation">:</span> hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>matery</code></pre></li><li><p>根据<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">readme配置文件</a>做进一步配置。</p></li><li><p>评论使用<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a>, 创建<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">OAuth application</a>后, 在matery的_config.yml中配置即可。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flyway的学习</title>
      <link href="/2019/11/21/flyway-de-xue-xi/"/>
      <url>/2019/11/21/flyway-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>数据库可以像代码一样, 使用flyway进行良好的版本控制。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h5 id="空数据库-最简单的方式"><a href="#空数据库-最简单的方式" class="headerlink" title="空数据库-最简单的方式"></a>空数据库-最简单的方式</h5><ul><li><p>flyway找不到<code>schema history table</code>时, 将创建默认名为<code>flyway_schema_history</code>的表。</p></li><li><p>flyway随后会扫描文件系统或application的classpath, 找到对应文件进行<code>migrations</code>。其可以是sql或java编写。</p></li><li><p>每次migration生效后, <code>flyway_schema_history</code>中会生成一条记录。</p><p><img src="/images/flyway_schema_history.jpg" alt="flyway_schema_history"></p></li><li><p>每次创建一个版本更高的<code>migration</code>, 当下次flyway运行时, 其将会找到并运行该<code>migration</code>来升级数据库。</p></li></ul><h5 id="非空数据库"><a href="#非空数据库" class="headerlink" title="非空数据库"></a>非空数据库</h5><p>指定baseline。</p><ul><li>baselineOnMigrate  是否开启baseline, 默认为false。</li><li>baselineVersion 高于该指定版本的才会进行migrate。</li><li>baselineDescription 描述。</li></ul><pre class=" language-shell"><code class="language-shell">flyway -baselineOnMigrate=true -baselineVersion=1 -baselineDescription="aaa" migrate</code></pre><h5 id="command-line"><a href="#command-line" class="headerlink" title="command-line"></a>command-line</h5><p>以此种方式为例进行说明。</p><ul><li><p>下载对应系统的flyway command-line tool。</p></li><li><p>进入到flyway文件夹。</p><pre class=" language-shell"><code class="language-shell">cd flyway-6.0.8</code></pre></li><li><p>配置./conf/flyway.conf</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">flyway.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/flyway?serverTimezone=UTC</span><span class="token attr-name">flyway.user</span><span class="token punctuation">=</span><span class="token attr-name">flyway.password</span><span class="token punctuation">=</span></code></pre></li><li><p>在./sql目录下添加sql文件, 命名为<code>V1__Create_person_table.sql</code>, <font color="red">注意V1后的下划线为两个</font>, V是version的缩写, 1为版本号, __后的为此次操作的描述。</p></li><li><p>执行flyway migrate, 即可在数据库看到改变。</p><pre class=" language-sh"><code class="language-sh">flyway-6.0.8> flyway migrate</code></pre></li></ul><p>还可通过API、maven、Gradle来实现, 其具体操作参见官方文档。</p><h5 id="Repeatable-Migrations"><a href="#Repeatable-Migrations" class="headerlink" title="Repeatable Migrations"></a>Repeatable Migrations</h5><p>命名规则: <code>R__people_view.sql</code>, 即使用<code>R</code>代替<code>V</code>,并且无需指定版本号, 其总是最后生效, 且可保证多次重复执行。一般用于创建 views/procedures/functions/packages/…</p><h5 id="Undo-Migrations"><a href="#Undo-Migrations" class="headerlink" title="Undo Migrations"></a>Undo Migrations</h5><p>命名规则: <code>U2__Add_people.sql</code>, U代替V, 其基于之前的migration均是成功的, 不能undo失败的migration。</p><p>当存在migration失败时, 需人工介入。</p><p>社区版不支持, 算了, 不用了。</p><h5 id="Dry-Runs"><a href="#Dry-Runs" class="headerlink" title="Dry Runs"></a>Dry Runs</h5><p>社区版不支持, 可生成该次会执行的sql改动, 便于检查。</p><h4 id="SQL-based-migrations"><a href="#SQL-based-migrations" class="headerlink" title="SQL-based migrations"></a>SQL-based migrations</h4><h5 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h5><p><img src="/images/flyway-naming.png" alt="flyway-naming"></p><p>Versioned可以省略Separator和Description(最好不要)。</p><h5 id="Discovery"><a href="#Discovery" class="headerlink" title="Discovery"></a>Discovery</h5><p>文件可以在filesystem或classpath, 分别使用对应的前缀, 即<code>filesystem:</code>或<code>classpath:</code>。</p><h5 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h5><p>flyway支持sql语义, 一行或多行语句。</p><p>单行注释(–)或多行注释(/**/)。</p><p>指定数据库的语义延伸。</p><h5 id="Placeholder-Replacement"><a href="#Placeholder-Replacement" class="headerlink" title="Placeholder Replacement"></a>Placeholder Replacement</h5><p>flyway支持占位符。</p><h4 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h4><p>7个命令: Migrate, Clean, Info, Validate, Undo, Baseline, Repair。</p><h5 id="Migrate"><a href="#Migrate" class="headerlink" title="Migrate"></a>Migrate</h5><p>flyway的中心功能, 其会扫描filesystem和classpath寻找可用的migration, 并与数据库里flyway_schema_history的版本进行比较, 执行需要执行的migration。</p><p>在启动时来执行migration, 避免数据库与代码的不一致。</p><h5 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h5><p><font color="red">在开发和测试环境很有用, 但不要在生产环境使用。</font></p><p>删除所有表, 试图, 存储过程, 触发器等。</p><h5 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h5><p>查看migrations的详细信息, 即flyway_schema_history的表信息。</p><h5 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h5><p>校验可用的migration与已生效的migration。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://flywaydb.org/getstarted/" target="_blank" rel="noopener">flyway官网</a></p><p><a href="https://flywaydb.org/download/" target="_blank" rel="noopener">下载地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC的学习</title>
      <link href="/2019/11/20/grpc-de-xue-xi/"/>
      <url>/2019/11/20/grpc-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>gRPC为Google的rpc实现, 使用proto buffer作为接口定义语言(Interface Definition Language, 即IDL)。</p><p>客户端可以像调用本地方法一样调用服务端方法。</p><p>在客户端保存有接口存根来进行方法调用，该存根有和服务器同样的方法; 服务端实现接口定义的方法, 来处理客户端的请求。</p><p> <img src="/images/grpc-model.svg" alt="Concept Diagram"></p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><h5 id="Service-definition"><a href="#Service-definition" class="headerlink" title="Service definition"></a>Service definition</h5><p>使用proto buffer定义接口(可以使用其它可选择的协议代替proto buffer)。</p><pre class=" language-protobuf"><code class="language-protobuf">service HelloService <span class="token punctuation">{</span>  rpc <span class="token function">SayHello</span> <span class="token punctuation">(</span>HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>HelloResponse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">message</span> HelloRequest <span class="token punctuation">{</span>  <span class="token primitive symbol">string</span> greeting <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">message</span> HelloResponse <span class="token punctuation">{</span>  <span class="token primitive symbol">string</span> reply <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>有四种接口方法</p><ul><li><p>像普通的函数,  一种请求类型, 一种返回类型。</p><pre class=" language-protobuf"><code class="language-protobuf">rpc <span class="token function">SayHello</span><span class="token punctuation">(</span>HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>HelloResponse<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>服务器返回流式数据, 在一次独立的调用中, gRPC保证其信息的顺序。</p><pre class=" language-protobuf"><code class="language-protobuf">rpc <span class="token function">LotsOfReplies</span><span class="token punctuation">(</span>HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>stream HelloResponse<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>客户端发送流式数据, 在一次独立的调用中, gRPC保证其信息的顺序。</p><pre class=" language-protobuf"><code class="language-protobuf">rpc <span class="token function">LotsOfGreetings</span><span class="token punctuation">(</span>stream HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>HelloResponse<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>双向流式数据, 请求流和返回流独立处理, 服务端可以接受完所有数据后再返回, 也可以边接受边回传数据。</p><p>在彼此的数据流中, 顺序得到保证。</p><pre class=" language-protobuf"><code class="language-protobuf">rpc <span class="token function">BidiHello</span><span class="token punctuation">(</span>stream HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>stream HelloResponse<span class="token punctuation">)</span></code></pre></li></ul><h5 id="Synchronous-vs-asynchronous"><a href="#Synchronous-vs-asynchronous" class="headerlink" title="Synchronous vs asynchronous"></a>Synchronous vs asynchronous</h5><p>同步调用会阻塞，其也是RPC的方法调用希望的做法, 但是在很多场景下, 需要异步调用。</p><p>grpc同时支持同步编程和异步编程。</p><h5 id="RPC-life-cycle"><a href="#RPC-life-cycle" class="headerlink" title="RPC life cycle"></a>RPC life cycle</h5><h6 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h6><ul><li>客户端调用方法时, 服务端将会收到通知, 并得到这次调用客户端的 <a href="#Metadata">Metadata</a>, 方法名, 及如果指定了的<a href="#deadline">Deadlines</a>。</li><li>服务端也会立即返回自己的Metadata(必须在response前返回), 或者在收到请求信息后。</li><li>服务端进行处理, 返回对应的数据, 包括状态码和状态信息等。</li><li>当此次请求成功时, 客户端得到返回, 一次调用结束。</li></ul><h6 id="Deadlines-Timeouts"><a href="#Deadlines-Timeouts" class="headerlink" title="Deadlines/Timeouts"></a><span id="deadline">Deadlines/Timeouts</span></h6><p>客户端可以指定超时时间,  当超时时，会返回<font color="red">DEADLINE_EXCEEDED</font>。</p><h6 id="RPC-termination"><a href="#RPC-termination" class="headerlink" title="RPC termination"></a>RPC termination</h6><p>客服端和服务端都可以决定一次调用什么时候结束。</p><p>当请求超过客户端设定的超时时间,  客户端会认定请求失败, 即使服务端随后成功处理并发送返回。</p><p>服务端也可以在客服端发送完请求数据前开始返回来完成这次请求。</p><h6 id="Cancelling-RPCs"><a href="#Cancelling-RPCs" class="headerlink" title="Cancelling RPCs"></a>Cancelling RPCs</h6><p>其不会<font color="red">undo</font>, 在撤销前的改变不会回滚。</p><h6 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a><span id="Metadata">Metadata</span></h6><p>键值对形式,  客户端通过metadata提供调用相关信息给服务端, 反之亦然。</p><h6 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h6><p>提供到指定地址的gRPC server的连接。</p><p>clients可以通过指定channel参数来修改gRPC的默认行为, 例如打开或关闭消息压缩。</p><p>channel有状态, 包括 <code>connected</code>  和 <code>idle</code>。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>gRPC支持多种认证机制。</p><ul><li>SSL/TLS</li><li>Token-based authentication with Google</li></ul><h5 id="Authentication-API"><a href="#Authentication-API" class="headerlink" title="Authentication API"></a>Authentication API</h5><h6 id="Credential-tpyes"><a href="#Credential-tpyes" class="headerlink" title="Credential tpyes"></a>Credential tpyes</h6><ul><li>Channel credentials</li><li>Call Credentials</li></ul><p>java的认证与授权官方推荐OpenSSl,  <a href="https://github.com/grpc/grpc-java/blob/master/SECURITY.md#transport-security-tls" target="_blank" rel="noopener">security</a>。</p><h4 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h4><h5 id="Standard-error-model"><a href="#Standard-error-model" class="headerlink" title="Standard error model"></a>Standard error model</h5><p>发生错误时, gRPC返回错误的status codes及可选的错误信息字符串(提供更详细的信息)。</p><h5 id="Richer-error-model"><a href="#Richer-error-model" class="headerlink" title="Richer error model"></a>Richer error model</h5><p>standard error model与grpc采用的数据交互形式无关, 但局限性较大, 不能详细描述错误信息。</p><p><a href="https://cloud.google.com/apis/design/errors#error_model" target="_blank" rel="noopener">错误模型</a></p><h4 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h4><p>结合<a href="https://www.grpc.io/docs/tutorials/basic/java/" target="_blank" rel="noopener">gRPC-Basics-Java</a>观看更好。</p><p><a href="https://github.com/xiaofeng333/hello_grpc" target="_blank" rel="noopener">本人例子项目</a></p><p><a href="https://github.com/grpc/grpc-java" target="_blank" rel="noopener">官方</a></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.grpc.io/docs/" target="_blank" rel="noopener">官方文档</a></p><p><a href="http://doc.oschina.net/grpc?t=56831" target="_blank" rel="noopener">grpc官方文档中文版</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grafana</title>
      <link href="/2019/11/20/grafana/"/>
      <url>/2019/11/20/grafana/</url>
      
        <content type="html"><![CDATA[<h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p>在mac环境下安装。</p><ul><li>安装</li></ul><pre class=" language-shell"><code class="language-shell">brew updatebrew install grafana</code></pre><ul><li>升级</li></ul><pre class=" language-shell"><code class="language-shell">brew updatebrew reinstall grafana</code></pre><ul><li>启动</li></ul><pre class=" language-shell"><code class="language-shell">brew services start grafana</code></pre><ul><li>默认访问地址: 127.0.0.1:3000</li><li>账号密码为admin/admin</li><li>安装路径: /usr/local/etc/grafana</li></ul><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h4><p>配置较多, 实际使用时查看<a href="https://grafana.com/docs/installation/configuration" target="_blank" rel="noopener">官方文档</a>即可, 以下只是随手记录, 并非最重要的参数。</p><ul><li><p>可以通过.ini文件或指定环境变量进行配置。</p><p>配置改变后, grafana需要重启生效。</p><p>在ini文件中使用<code>;</code>来添加注释。</p></li><li><p>默认配置: $WORKING_DIR/conf/defaults.ini;</p><p>自定义配置: $WORKING_DIR/conf/custom.ini;</p><p>自定义配置可通过–config来重载。</p></li></ul><h5 id="environment-variables"><a href="#environment-variables" class="headerlink" title="environment variables"></a>environment variables</h5><p>语义如下, SectionName为.ini文件中<code>[]</code>的内容。环境变量名称均为大写, <code>.</code>替换为<code>.</code>。</p><pre class=" language-shell"><code class="language-shell">GF_<SectionName>_<keyName></code></pre><p>例子如下:</p><pre class=" language-ini"><code class="language-ini"># default section<span class="token constant">instance_name</span> <span class="token attr-value"><span class="token punctuation">=</span> ${HOSTNAME}</span><span class="token selector">[security]</span><span class="token constant">admin_user</span> <span class="token attr-value"><span class="token punctuation">=</span> admin</span><span class="token selector">[auth.google]</span><span class="token constant">client_secret</span> <span class="token attr-value"><span class="token punctuation">=</span> 0ldS3cretKey</span></code></pre><pre class=" language-shell"><code class="language-shell">export GF_DEFAULT_INSTANCE_NAME=my-instanceexport GF_SECURITY_ADMIN_USER=trueexport GF_AUTH_GOOGLE_CLIENT_SECRET=newS3cretKey</code></pre><ul><li>temp_data_lifetime: 临时数据保存多久, 默认为<code>24h</code>, 支持的单位为<code>h(hour)</code>, <code>m(minutes)</code>, 0标识永久保存, 可设置<code>10h30m</code>。</li><li>logs: 日志文件路径。</li><li>还可以配置使用的协议、插件路径、端口和域名等。</li></ul><h5 id="databse"><a href="#databse" class="headerlink" title="databse"></a>databse</h5><p>默认使用内嵌的sqlite3。</p><ul><li>url: 数据库url。</li><li>type: 数据库类型: mysql、postgres、sqlite3, 例如<code>mysql:user:secret@host:port/database</code>。</li><li>path: 当使用sqllite3时, 用来指定文件地址。</li><li>host: 当使用mysql或postgres, 使用ip(hostname):port或unix sockets。</li><li>password: 当密码包含#或; 时, 使用三个引号包裹, 例如<code>"""#password;"""</code>。</li><li>log_queries: 值为true时, 记录sql语句及执行时间。 </li><li>max_idle_conn: 最大的空闲连接数。</li><li>max_open_conn: 最大的并发连接数。</li></ul><h5 id="security"><a href="#security" class="headerlink" title="security"></a>security</h5><p>当账户名和密码在数据库user表存在时, 修改ini文件并不会起作用, 可清空表重启gragana, 默认为内嵌的sqlite3, 如下所示。</p><pre class=" language-sqlite"><code class="language-sqlite"># cd /usr/local/var/lib/grafana/sqlite3 grafana.dbselect * from user;delete from user;</code></pre><ul><li>admin_user: 默认为admin。</li><li>admin_password: 默认为admin。</li><li>grafana也支持第三方授权, 如Google OAuth、Github OAuth、LDAP Authentication等。</li></ul><h5 id="analytics"><a href="#analytics" class="headerlink" title="analytics"></a>analytics</h5><ul><li>reporting_enabled: grafana发送匿名使用统计至<code>stats.grafana.org</code>。</li><li>google_analytocs_ua_id: google的统计id。</li><li>check_for_updates: 检查更新。</li></ul><h5 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h5><ul><li>enabled: 默认为true, 通过http接口<code>/metrics</code>。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proto buffer 学习</title>
      <link href="/2019/11/14/proto-buffer-xue-xi/"/>
      <url>/2019/11/14/proto-buffer-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>protobuffer是与语言无关、与平台无关、可扩展的数据格式,  可用于数据通信及存储等, 比XML更小、更快、更简洁。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="定义proto-file"><a href="#定义proto-file" class="headerlink" title="定义proto file"></a>定义proto file</h4><pre class=" language-protobuf"><code class="language-protobuf">syntax <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// this is request</span><span class="token keyword">message</span> SearchRequest <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// reserved filed number which cannot be used</span>  <span class="token builtin">reserved</span> <span class="token number">4</span><span class="token punctuation">;</span>      <span class="token builtin">optional</span> <span class="token primitive symbol">string</span> voice_box <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token builtin">required</span> <span class="token primitive symbol">int32</span> host <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token builtin">repeated</span> <span class="token primitive symbol">int32</span> display <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* this is response*/</span><span class="token keyword">message</span> SerachResponse <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><ul><li><p>第一行标识使用proto3语义， 如未在第一个非注释行指定, 则默认使用proto2。</p></li><li><p>每个filed有命名和类型, 类型可以是 numbers(整型或浮点型)、  booleans 、 strings 、enumerations、bytes, 甚至是proto buffer类型。proto字段类型与不同语言的对应关系: <a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">scalar value types</a>。</p></li><li><p>每个字段类型后都有一个唯一标识号, 此标识号会在proto二进制文件中使用, 标识号在1-15内使用一个字节去编码, 16至2047使用两个字节去编码, 故1-15为频繁使用的字段保留,  也应留存以便未来使用。</p></li><li><p><font style="color:red"> reserved, 保证不被后来的使用者重新使用</font></p></li><li><p>不能在.proto文件中使用19000-19999作为字段标识号, 因为它们是proto保留字段数。</p></li><li><p>使用//或/**/添加注释。</p></li><li><p>singular(optional 或 required): 至多1个, repeated: 不限制个数, 0或多个, 相对而言使用required弊多于利。</p></li></ul><h4 id="枚举字段"><a href="#枚举字段" class="headerlink" title="枚举字段"></a>枚举字段</h4><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">message</span> SearchRequest <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">enum</span> Corpus <span class="token punctuation">{</span>       <span class="token builtin">reserved</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">9</span> to <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">40</span> to max<span class="token punctuation">;</span>      option allow_alias <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    UNIVERSAL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    WEB <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    IMAGES <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    LOCAL <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    NEWS <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    PRODUCTS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    VIDEO <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    START <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    BEGIN <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  Corpus corpus <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>必须有0值，此为默认值。</li><li>0值必须是第一个元素, 与proto2兼容(其默认第一个枚举值为默认值)。</li><li>allow_alias = true, 即允许在enum中使用别名,  即START与BEGIN。</li><li>可在其他message type中使用该enum, 即MessageType.EnumType。</li><li><font color="green">reserved, 保证不被后来的使用者重新使用</font></li></ul><h4 id="定义message-type-field"><a href="#定义message-type-field" class="headerlink" title="定义message type field"></a>定义message type field</h4><p>proto编译器找寻proto文件的路径通过命令行里的 -I/–proto_path指定, 如若不存在, 其在编译器执行的当前目录   下找寻。</p><ul><li><p>在同一proto文件中, 可直接使用。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">message</span> SearchResponse <span class="token punctuation">{</span>  <span class="token builtin">repeated</span> Result results <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">message</span> Result <span class="token punctuation">{</span>  <span class="token primitive symbol">string</span> url <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>在同一目录下的其他文件中,  需导入该proto文件。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">import</span> <span class="token string">"myproject/other_protos.proto"</span><span class="token punctuation">;</span></code></pre></li><li><p>非同一目录下,  使用import public</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">import</span> public <span class="token string">"new.proto"</span></code></pre></li></ul><h4 id="更新Message-Type"><a href="#更新Message-Type" class="headerlink" title="更新Message Type"></a>更新Message Type</h4><p> 注意事项:</p><ul><li>不要改动任何已存在的字段标识号。</li><li>添加新字段时, 应明确知晓其默认值, 以便新代码可以正常处理老proto生成的信息。</li><li>字段可以被删除, 但不能被再次使用, 可以将其置为<font color="blue">reserved</font>或添加<font color="blue"> OBSOLETE_ </font>前缀。</li></ul><h4 id="未知字段"><a href="#未知字段" class="headerlink" title="未知字段"></a>未知字段</h4><p>当老版本解析新版本中新增字段时，其新增字段属于未知字段。</p><p>版本3.5后, proto会保留未知字段, 而非丢弃。</p><h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><p>Any可以允许使用message tpye, 而不引入其proto文件。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">import</span> <span class="token string">"google/protobuf/any.proto"</span><span class="token punctuation">;</span><span class="token keyword">message</span> ErrorStatus <span class="token punctuation">{</span>    String <span class="token keyword">message</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token builtin">repeated</span> google<span class="token punctuation">.</span>protobuf<span class="token punctuation">.</span>Any details <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="oneof"><a href="#oneof" class="headerlink" title="oneof"></a>oneof</h4><p>每次最多只有一个字段类型被设置时, 可以使用oneof, 不能在oneof中使用repeated字段。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">message</span> SampleMessage <span class="token punctuation">{</span>  oneof test_oneof <span class="token punctuation">{</span>    <span class="token primitive symbol">string</span> name <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    SubMessage sub_message <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>设置oneof字段时, 如同时设置多个,  只有最后一个会被保留。</li><li>如果解析器同时发现多个相同的oneof, 只有最后一个oneof会被保留。</li><li>谨慎添加或删除oneof字段。</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><pre class=" language-protobuf"><code class="language-protobuf"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// map&lt;key_type, value_type> map_field = N;</span>map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Project<span class="token operator">></span> projects <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><ul><li><p>key_type可以是int或string类型, enum、floating和enum不是有效的key_type。</p></li><li><p>value_type可以是任何类型, 但不能是map。</p></li><li><p>Map字段不能使repeated。</p><h5 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h5></li></ul><pre class=" language-protobuf"><code class="language-protobuf"><span class="token comment" spellcheck="true">// 此与map等价, 任何支持map的proto协议都必须接受如下定义。</span><span class="token keyword">message</span> MapFieldEntry <span class="token punctuation">{</span>  key_type key <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  value_type value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token builtin">repeated</span> MapFieldEntry map_field <span class="token operator">=</span> N<span class="token punctuation">;</span></code></pre><h4 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h4><p>可以在proto文件中使用package来防止名称冲突。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">package</span> foo<span class="token punctuation">.</span>bar<span class="token punctuation">;</span><span class="token keyword">message</span> Open <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><h4 id="Defining-Services"><a href="#Defining-Services" class="headerlink" title="Defining Services"></a>Defining Services</h4><p>在proto文件中定义rpc接口。</p><pre class=" language-protobuf"><code class="language-protobuf">service SearchService <span class="token punctuation">{</span>    rpc <span class="token function">Search</span> <span class="token punctuation">(</span>SearchRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>SearchResponse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="转为JSON"><a href="#转为JSON" class="headerlink" title="转为JSON"></a>转为JSON</h4><p><a href="https://developers.google.com/protocol-buffers/docs/proto3#json" target="_blank" rel="noopener">JSON Mapping</a></p><h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4><ul><li><p>java_package, 如果不是生成java代码, 其不起作用。</p><pre class=" language-protobuf"><code class="language-protobuf">option java_package <span class="token operator">=</span> <span class="token string">"com.example.foo"</span><span class="token punctuation">;</span></code></pre></li><li><p>java_multiple_files, 将proto文件内定义的message type生成多个java类。</p><pre class=" language-protobuf"><code class="language-protobuf">option java_multiple_files <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre></li><li><p>java_outer_classname, 指定生成的java类名。</p><pre class=" language-protobuf"><code class="language-protobuf">option java_outer_classname <span class="token operator">=</span> <span class="token string">"Ponycopter"</span><span class="token punctuation">;</span></code></pre></li><li><p>optimize_for,  可用的值有三个，SPEED、CODE_SIZE、LITE_RUNTIME。默认为SPEED, 对于后台应用, 使用默认的即可。</p><pre class=" language-protobuf"><code class="language-protobuf">option optimize_for <span class="token operator">=</span> CODE_SIZE<span class="token punctuation">;</span></code></pre></li><li><p>deprecated,  对于java语言, 对应字段标注@Deprecated注解。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token primitive symbol">int32</span> old_field <span class="token operator">=</span> <span class="token number">6</span> <span class="token punctuation">[</span>deprecated<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></li><li><p>还可以自定义options, 感兴趣可查看<a href="https://developers.google.com/protocol-buffers/docs/proto.html#customoptions" target="_blank" rel="noopener">custom options</a>。</p></li></ul><h4 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h4><pre class=" language-protobuf"><code class="language-protobuf">protoc <span class="token operator">--</span>proto_path<span class="token operator">=</span>IMPORT_PATH <span class="token operator">--</span>cpp_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>java_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>python_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>go_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>ruby_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>objc_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>csharp_out<span class="token operator">=</span>DST_DIR path<span class="token operator">/</span>to<span class="token operator">/</span>file<span class="token punctuation">.</span>proto</code></pre><ul><li>proto_path, 指定proto文件所在位置, 可指定多次, -I是其简化写法。</li><li>java_out即可生成java代码, 其DST_DIR可指定为zip或jar, 则输出文件即为对应格式。</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="noopener">package download</a></p><p>找到对应系统的安装包:  protoc-$VERSION-$PLATFORM.zip, 下载解压后,  配置环境变量, 即可使用protoc生成类文件。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">protocol buffers overview</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">language guide(proto3)</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">encoding</a></p><p><a href="https://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html" target="_blank" rel="noopener">Protobuf语言指南-很全-官方文档中文版</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> data-serialization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring boot maven plugin简介</title>
      <link href="/2019/05/19/spring-boot-maven-plugin-jian-jie/"/>
      <url>/2019/05/19/spring-boot-maven-plugin-jian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-Boot-Maven-Plugin简介"><a href="#Spring-Boot-Maven-Plugin简介" class="headerlink" title="Spring Boot Maven Plugin简介"></a>Spring Boot Maven Plugin简介</h3><h5 id="在pom-xml中引入"><a href="#在pom-xml中引入" class="headerlink" title="在pom.xml中引入"></a>在pom.xml中引入</h5><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>repackage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>              ...          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span></code></pre><h4 id="包含的goals"><a href="#包含的goals" class="headerlink" title="包含的goals"></a>包含的goals</h4><h5 id="spring-boot-run"><a href="#spring-boot-run" class="headerlink" title="spring-boot:run"></a>spring-boot:run</h5><p>运行SpringBoot应用</p><h5 id="spring-boot-repackage"><a href="#spring-boot-repackage" class="headerlink" title="spring-boot:repackage"></a>spring-boot:repackage</h5><p>将jar/war包重新包装成可执行。</p><p>使用 layout=NONE 可以将依赖打入jar包, 但非可执行jar包。</p><h6 id="classifier"><a href="#classifier" class="headerlink" title="classifier"></a>classifier</h6><p>因为默认情况下, repackage将会替换原jar包, 故当项目被别的项目依赖时, 可添加classifier, 以做区分。</p><pre class=" language-xml"><code class="language-xml">...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classifier</span><span class="token punctuation">></span></span>exec<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classifier</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>...</code></pre><p>attach</p><p>将会生成可执行jar包和original包, 只有original会被installe和deployed(jar包名称不会带origina)l</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>attach</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>attach</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h5 id="spring-boot-start-and-spring-boot-stop"><a href="#spring-boot-start-and-spring-boot-stop" class="headerlink" title="spring-boot:start and spring-boot:stop"></a>spring-boot:start and spring-boot:stop</h5><p>在mvn integration-test阶段, 管理SpringBoot应用的生命周期。</p><h6 id="分配随机端口"><a href="#分配随机端口" class="headerlink" title="分配随机端口"></a>分配随机端口</h6><p><a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/maven-plugin/examples/it-random-port.html" target="_blank" rel="noopener">random port</a></p><h6 id="跳过完整性测试"><a href="#跳过完整性测试" class="headerlink" title="跳过完整性测试"></a>跳过完整性测试</h6><p>添加属性，用于configuration。</p><p><a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/maven-plugin/examples/it-skip.html" target="_blank" rel="noopener">skip test</a></p><h6 id="指定profle"><a href="#指定profle" class="headerlink" title="指定profle"></a>指定profle</h6><p>如下激活了foo和bar的profile</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">></span></span>foo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">></span></span>bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h5 id="spring-boot-build-info"><a href="#spring-boot-build-info" class="headerlink" title="spring-boot:build-info"></a>spring-boot:build-info</h5><p>基于当前maven项目生成build-info.propertie，可被Actuator使用。</p><h5 id="spring-boot-help"><a href="#spring-boot-help" class="headerlink" title="spring-boot:help"></a>spring-boot:help</h5><p>展示关于spring-boot-maven-plugin的帮助信息.<br>如下所示</p><pre><code>mvn spring-boot:help -Ddetail=true -Dgoal=&lt;goal-name&gt; </code></pre><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/maven-plugin/plugin-info.html" target="_blank" rel="noopener">Spring Boot Maven Plugin</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-菜鸟教程</title>
      <link href="/2019/05/19/python-cai-niao-jiao-cheng/"/>
      <url>/2019/05/19/python-cai-niao-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul><li><p>注释</p><p>以#开头, 或 ‘’’ 和 “””。</p></li><li><p>行与缩进</p><p>使用缩进来表示代码块, 同一个代码块的语句必须包含相同的缩进空格数。</p><p>缩进数的空格数不一致，会导致运行错误。</p></li><li><p>多行语句</p><p>语句很长，可以使用反斜杠\来实现多行语句。</p><pre class=" language-python"><code class="language-python">total <span class="token operator">=</span> item_one <span class="token operator">+</span> \        item_two <span class="token operator">+</span> \        item_three</code></pre></li><li><p>数字类型</p><p>整数(int)、布尔型(bool)、浮点数(float)和复数(complex)。</p><p>int表示为长整型。</p><p>True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。<br>数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。<br>在混合计算时，Python会把整型转换成为浮点数。</p></li><li><p>字符串</p><p>字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</p><p>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</p><p>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</p></li><li><p>空行</p><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是Python语法的一部分。</p></li><li><p>Print 输出<br>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=“”</p></li><li><p>import 与 from…import</p><p>import 或者 from…import 来导入相应的模块。</p><p>import导入整个模块。</p><p>from…import从某个模块中导入多个函数。</p></li></ul><h5 id="Python3-命令行参数"><a href="#Python3-命令行参数" class="headerlink" title="Python3 命令行参数"></a>Python3 命令行参数</h5><p>Python 提供了 getopt 模块来获取命令行参数。</p><h5 id="Python3-基本数据类型"><a href="#Python3-基本数据类型" class="headerlink" title="Python3 基本数据类型"></a>Python3 基本数据类型</h5><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><h6 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h6><p>Python允许同时为多个变量赋值, 也可以为多个对象指定多个变量。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> b <span class="token operator">=</span> c <span class="token operator">=</span> <span class="token number">1</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span></code></pre><h6 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h6><p>Python3 的六个标准数据类型中:</p><ul><li><p>不可变数据</p><p>Number、String、Tuple</p></li><li><p>可变数据</p><p>List、Dictionary、Set</p></li></ul><p>内置的 type() 函数可以用来查询变量所指的对象类型, 也可用isinstance来判断。</p><p>type()不会认为子类是一种父类类型, isinstance()会认为子类是一种父类类型。</p><p>一个变量可以通过赋值指向不同类型的对象。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>type<span class="token punctuation">(</span>a<span class="token punctuation">)</span>isinstance<span class="token punctuation">(</span>a<span class="token punctuation">,</span> int<span class="token punctuation">)</span></code></pre><p>可以使用del语句删除一些对象引用。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">del</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d</code></pre><ul><li><p>List</p><p>列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>加号 + 是列表连接运算符，星号 * 是重复操作</p></li><li><p>Tuple</p><p>元组的元素不能修改，但其中可变数据可以修改。</p></li><li><p>set</p><p>元素不重复</p><p>创建一个空集合必须用 set()</p></li><li><p>Dictionary</p><p>键(key)必须使用不可变类型。</p><p>在同一个字典中，键(key)必须是唯一的。</p></li></ul><p>​       创建空字典使用 { }</p><h5 id="python解释器"><a href="#python解释器" class="headerlink" title="python解释器"></a>python解释器</h5><p>Python 解释器不止一种哦，有 CPython、IPython、Jython、PyPy 等。</p><p>Jython 是专为 Java 平台设计的 Python 解释器，它把 Python 代码编译成 Java 字节码执行。</p><h5 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h5><p>1.在python中操作集合或字典中不存在的元素会报错。</p><p>2.右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span>    b <span class="token operator">=</span> <span class="token number">2</span>    a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span class="token operator">+</span>b    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 2</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3</span></code></pre><p>3.关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符。</p><p>4.递归以空间换取可读性，当过深时，会造成溢出。</p><h5 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h5><h6 id="ifelse"><a href="#ifelse" class="headerlink" title="ifelse"></a>ifelse</h6><p>if语句的关键字为：if – elif – else。</p><h6 id="while"><a href="#while" class="headerlink" title="while"></a>while</h6><p>在while中可添加else的语句块</p><pre class=" language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">while</span> count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>     <span class="token keyword">print</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">" 小于 5"</span><span class="token punctuation">)</span>     count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">else</span><span class="token punctuation">:</span>     <span class="token keyword">print</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">" 大于或等于 5"</span><span class="token punctuation">)</span></code></pre><h6 id="for"><a href="#for" class="headerlink" title="for"></a>for</h6><p>for循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p><h6 id="range"><a href="#range" class="headerlink" title="range"></a>range</h6><p>内置range()函数, 会生成数列。</p><h6 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h6><p>pass是空语句，是为了保持程序结构的完整性。</p><h5 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h5><p>1.把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p><p>2.StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p><p>3.yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 斐波那契</span><span class="token keyword">def</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">></span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>             <span class="token keyword">return</span>        <span class="token keyword">yield</span> a        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b        counter <span class="token operator">+=</span> <span class="token number">1</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven小知识-资源文件变量替换</title>
      <link href="/2019/05/19/maven-xiao-zhi-shi-zi-yuan-wen-jian-bian-liang-ti-huan/"/>
      <url>/2019/05/19/maven-xiao-zhi-shi-zi-yuan-wen-jian-bian-liang-ti-huan/</url>
      
        <content type="html"><![CDATA[<p>项目在不同环境下部署时，使用的属性是不同的，这时可以使用MAVEN进行资源文件的过滤，在打包时传递参数，打出适合部署在对应环境的资源文件。</p><p>如定义了如下资源文件:</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">spring.env</span><span class="token punctuation">=</span><span class="token attr-value">${env}</span></code></pre><p>pom文件中可添加如下信息</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--使用了 spring-boot-starter-parent 做项目版本管理，其默认值为@--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource.delimiter</span><span class="token punctuation">></span></span>${}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource.delimiter</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--默认值--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">></span></span>DEV<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置文件的环境变量 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--可通过includes指定需要进行过滤的文件--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--可通过excludes指定排除需要进行过滤的文件, 这里的路径与上相同, 否则其他文件将不会被打包--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>maven打包命令, 将该环境下需要使用的参数进行传递</p><pre class=" language-script"><code class="language-script">mvn clean install -Denv=PRO</code></pre><p>当参数过多时，可同时使用profiles，将无需保密的参数定义在pom中，通过激活对应profile的形式来进行参数替换。易可通过使用apollo等平台，在此只需动态配置环境即可。</p><pre><code>mvn clean install -P${profileId}</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/cf3bd9ddfe6f" target="_blank" rel="noopener">Maven打包时，环境变量替换,并解决spring-boot项目中${}无效的问题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDAP学习与介绍</title>
      <link href="/2019/04/04/ldap-xue-xi-yu-jie-shao/"/>
      <url>/2019/04/04/ldap-xue-xi-yu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>LDAP是轻量目录访问协议(Lightweight Directory Access Protocol)的缩写，其结构用树来表示，而不是用表格。它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。</p><p>LDAP是一种开放Internet标准，LDAP协议是跨平台的Interent协议。</p><p>类似以下的信息适合储存在目录中：</p><ul><li>企业员工信息，如姓名、电话、邮箱等；</li><li>公用证书和安全密钥；</li><li>公司的物理设备信息，如服务器，它的IP地址、存放位置、厂商、购买时间等；</li></ul><h4 id="LDAP组织数据的方式"><a href="#LDAP组织数据的方式" class="headerlink" title="LDAP组织数据的方式"></a>LDAP组织数据的方式</h4><p><img src="/images/ldap_intro_dctree.png" alt="LDAP组织数据的方式"></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h5><p>条目，也叫记录项，是LDAP中最基本的颗粒，就像字典中的词条，或者是数据库中的记录。通常对LDAP的添加、删除、更改、检索都是以条目为基本对象的。</p><p><code>dn</code>：每一个条目都有一个唯一的标识名（distinguished Name ，DN），如上图中一个 dn：”cn=baby,ou=marketing,ou=people,dc=mydomain,dc=org” 。通过DN的层次型语法结构，可以方便地表示出条目在LDAP树中的位置，通常用于检索。</p><p><code>rdn</code>：一般指dn逗号最左边的部分，如cn=baby。它与RootDN不同，RootDN通常与RootPW同时出现，特指管理LDAP中信息的最高权限用户。</p><p><code>Base DN</code>：LDAP目录树的最顶部就是根，也就是所谓的“Base DN”，如”dc=mydomain,dc=org”。</p><h5 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h5><p>每个条目都可以有很多属性（Attribute），比如常见的人都有姓名、地址、电话等属性。每个属性都有名称及对应的值，属性值可以有单个、多个，比如你有多个邮箱。</p><p><code>属性不是随便定义的，需要符合一定的规则</code>，而这个规则可以通过schema制定。比如，如果一个entry没有包含在 inetorgperson 这个 schema 中的<code>objectClass: inetOrgPerson</code>，那么就不能为它指定employeeNumber属性，因为employeeNumber是在inetOrgPerson中定义的。</p><p>LDAP为人员组织机构中常见的对象都设计了属性(比如commonName，surname)。下面有一些常用的别名：</p><table><thead><tr><th>属性</th><th>别名</th><th>语法</th><th>描述</th><th>值(举例)</th></tr></thead><tbody><tr><td>commonName</td><td>cn</td><td>Directory String</td><td>姓名</td><td>sean</td></tr><tr><td>surname</td><td>sn</td><td>Directory String</td><td>姓</td><td>Chow</td></tr><tr><td>organizationalUnitName</td><td>ou</td><td>Directory String</td><td>单位（部门）名称</td><td>IT_SECTION</td></tr><tr><td>organization</td><td>o</td><td>Directory String</td><td>组织（公司）名称</td><td>example</td></tr><tr><td>telephoneNumber</td><td></td><td>Telephone Number</td><td>电话号码</td><td>110</td></tr><tr><td>objectClass</td><td></td><td></td><td>内置属性</td><td>organizationalPerson</td></tr></tbody></table><h5 id="ObjectClass"><a href="#ObjectClass" class="headerlink" title="ObjectClass"></a>ObjectClass</h5><p>对象类是属性的集合，LDAP预想了很多人员组织机构中常见的对象，并将其封装成对象类。比如人员（person）含有姓（sn）、名（cn）、电话(telephoneNumber)、密码(userPassword)等属性，单位职工(organizationalPerson)是人员(person)的继承类，除了上述属性之外还含有职务（title）、邮政编码（postalCode）、通信地址(postalAddress)等属性。</p><p>通过对象类可以方便的定义条目类型。每个条目可以直接继承多个对象类，这样就继承了各种属性。如果2个对象类中有相同的属性，则条目继承后只会保留1个属性。对象类同时也规定了哪些属性是基本信息，必须含有(Must 活Required，必要属性)：哪些属性是扩展信息，可以含有（May或Optional，可选属性）。</p><p>对象类有三种类型：结构类型（Structural）、抽象类型(Abstract)和辅助类型（Auxiliary）。结构类型是最基本的类型，它规定了对象实体的基本属性，每个条目属于且仅属于一个结构型对象类。抽象类型可以是结构类型或其他抽象类型父类，它将对象属性中共性的部分组织在一起，称为其他类的模板，条目不能直接集成抽象型对象类。辅助类型规定了对象实体的扩展属性。每个条目至少有一个结构性对象类。</p><p>对象类本身是可以相互继承的，所以对象类的根类是top抽象型对象类。以常用的人员类型为例，他们的继承关系：</p><p>!(ObjectClass)[/images/ldap_objectclass.jpg]</p><h5 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h5><p>对象类（ObjectClass）、属性类型（AttributeType）、语法（Syntax）分别约定了条目、属性、值，他们之间的关系如下图所示。所以这些构成了模式(Schema)——对象类的集合。条目数据在导入时通常需要接受模式检查，它确保了目录中所有的条目数据结构都是一致的。</p><p><img src="/images/ldap_schema_attr_entry.jpg" alt="schema"></p><h5 id="LDIF"><a href="#LDIF" class="headerlink" title="LDIF"></a>LDIF</h5><p>LDIF（LDAP Data Interchange Format，数据交换格式）是LDAP数据库信息的一种文本格式，用于数据的导入导出，每行都是“属性: 值”对。</p><h4 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h4><p>在ubuntu上安装未能成功。</p><p>可参考<a href="https://myanbin.github.io/post/openldap-in-centos-7.html" target="_blank" rel="noopener">CentOS 7 环境下 OpenLDAP 的安装与配置</a>在centos上安装成功。</p><p>其中不同点:</p><p>1.chdomain.ldif中{2}mdb中的mdb需通过</p><pre class=" language-shell"><code class="language-shell">ls /etc/openldap/slapd.d/cn=config/ </code></pre><p>此命令查看如下格式文件。</p><p>我本机为olcDatabase={2}hdb.ldif，故我在此书写为hdb。</p><p>2.访问<a href="http://ip/phpldapadmin后出现This" target="_blank" rel="noopener">http://ip/phpldapadmin后出现This</a> base cannot be created with PLA.</p><p>可参考<a href="https://blog.51cto.com/tingdongwang/1733005" target="_blank" rel="noopener">关于OpenLDAPAdmin管理页面提示“This base cannot be created with PLA“问题</a>修改。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://segmentfault.com/a/1190000002607140" target="_blank" rel="noopener">LDAP服务器的概念和原理简单介绍</a></p><p><a href="https://cloud.tencent.com/developer/article/1380076" target="_blank" rel="noopener">OpenLDAP管理工具之LDAP Admin</a></p><p><a href="https://myanbin.github.io/post/openldap-in-centos-7.html" target="_blank" rel="noopener">CentOS 7 环境下 OpenLDAP 的安装与配置</a></p><p><a href="https://blog.51cto.com/tingdongwang/1733005" target="_blank" rel="noopener">关于OpenLDAPAdmin管理页面提示“This base cannot be created with PLA“问题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringData</title>
      <link href="/2019/03/30/springdata/"/>
      <url>/2019/03/30/springdata/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringData"><a href="#SpringData" class="headerlink" title="SpringData"></a>SpringData</h3><p>Spring Data存储库抽象的目标是显着减少为各种持久性存储实现数据访问层所需的样板代码量。</p><p>Spring Data存储库抽象中的中央接口是Repository。它将域类以及域类的ID类型作为类型参数进行管理。此接口主要用作标记接口，用于捕获要使用的类型，并帮助您发现扩展此接口的接口。(CrudRepository, PagingAndSortingRepository)</p><h4 id="Querydsl"><a href="#Querydsl" class="headerlink" title="Querydsl"></a>Querydsl</h4><p>使用Querydsl支持，Repository需继承QuerydslPredicateExecutor</p><pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">UserRepository</span> <span class="token keyword">extends</span> <span class="token class-name">CrudRepository</span><span class="token operator">&lt;</span>User<span class="token punctuation">,</span> Long<span class="token operator">></span><span class="token punctuation">,</span> QuerydslPredicateExecutor<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>需引入依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.querydsl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>querydsl-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${querydsl.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.querydsl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>querydsl-apt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${querydsl.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>添加插件</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.mysema.maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>apt-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>generate-sources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>process<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>outputDirectory</span><span class="token punctuation">></span></span>target/generated-sources/java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>outputDirectory</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>processor</span><span class="token punctuation">></span></span>com.querydsl.apt.jpa.JPAAnnotationProcessor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>processor</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springsecurity参考手册</title>
      <link href="/2019/03/30/springsecurity-can-kao-shou-ce/"/>
      <url>/2019/03/30/springsecurity-can-kao-shou-ce/</url>
      
        <content type="html"><![CDATA[<h3 id="创建java配置"><a href="#创建java配置" class="headerlink" title="创建java配置"></a>创建java配置</h3><p><img src="C:%5CUsers%5Cfengchaofan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1553933604145.png" alt="1553933604145"></p><p>1.使用@EnableWebSecurity 注解启用Web安全功能</p><p>2.创建类SecurityConfiguration继承WebSecurityConfigurerAdapter，来对应用中所有的安全相关的事项（所有url，验证用户名密码，表单重定向等）进行控制，这个配置在你的应用程序中创建一个springSecurityFilterChain 的Servlet的过滤器，负责所有安全。</p><p>WebSecurityConfigurerAdapter共有三个configure方法</p><pre><code>configure(WebSecurity) 通过重载，配置Spring Security的Filter链configure(HttpSecurity) 通过重载，配置如何通过拦截器保护请求configure(AuthenticationManagerBuilder) 通过重载，配置user-detail服务</code></pre><h4 id="Filter链配置"><a href="#Filter链配置" class="headerlink" title="Filter链配置"></a>Filter链配置</h4><h4 id="HttpSecurity配置"><a href="#HttpSecurity配置" class="headerlink" title="HttpSecurity配置"></a>HttpSecurity配置</h4><pre><code>protected void configure(HttpSecurity http) throws Exception {    http        .authorizeRequests()            .anyRequest().authenticated()            .and()        .formLogin()            .and()        .httpBasic();}</code></pre><p>上面的默认配置:</p><ul><li>应用中的所有请求都需要用户被认证</li><li>允许用户进行基于表单的认证(WEB可用)</li><li>允许用户使用HTTP基于验证进行认证</li></ul><h4 id="用户存储配置"><a href="#用户存储配置" class="headerlink" title="用户存储配置"></a>用户存储配置</h4><p>configure(AuthenticationManagerBuilder) 方法中可配置多个用户存储。</p><h5 id="JDBC配置"><a href="#JDBC配置" class="headerlink" title="JDBC配置"></a>JDBC配置</h5><pre><code>@Autowiredprivate DataSource dataSource;@Overridepublic void configure(AuthenticationManagerBuilder auth)throws Exception{    //基于数据库的用户存储、认证    auth.jdbcAuthentication().dataSource(dataSource)        .usersByUsernameQuery("select account,password,true from user where account=?")        .authoritiesByUsernameQuery("select account,role from user where account=?")；}</code></pre><h5 id="LDAP配置"><a href="#LDAP配置" class="headerlink" title="LDAP配置"></a>LDAP配置</h5><pre><code>@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {    auth        .ldapAuthentication()            .userDnPatterns("uid={0},ou=people")            .groupSearchBase("ou=groups");}</code></pre><h5 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h5><p>实现接口UserDetailsService的loadUserByUsername(String username)，返回的是代表用户的UserDetails对象。<br>然后通过auth.userDetailsService()方法将其设置到安全配置中,userDetailsService()类似于jdbcAuthentication()和ldapAuthentication()，配置了一个用户存储。</p><h3 id="方法安全"><a href="#方法安全" class="headerlink" title="方法安全"></a>方法安全</h3><p>在任何使用<code>@Configuration</code>的实例上，使用<code>@EnableGlobalMethodSecurity</code>注解来启用基于注解的安全性,添加一个注解到一个方法（或者一个类）限制对相应方法的访问。</p><p>可以在同一个应用程序中启用多种注解，但是在一个接口或者类中只能使用一种类型的注解，否则会出现不明确的行为。如果对特定的方法使用了两个注解，只有其中的一个会被应用。</p><p><img src="C:%5CUsers%5Cfengchaofan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1553938519459.png" alt="1553938519459"></p><p><img src="C:%5CUsers%5Cfengchaofan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1553938541419.png" alt="1553938541419"></p><h3 id="当前用户获取信息"><a href="#当前用户获取信息" class="headerlink" title="当前用户获取信息"></a>当前用户获取信息</h3><p>将如下代码写在类的方法中，交由Spring管理</p><p><img src="C:%5CUsers%5Cfengchaofan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1554033780770.png" alt="1554033780770"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> spring security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring security总结</title>
      <link href="/2019/03/10/spring-security-zong-jie/"/>
      <url>/2019/03/10/spring-security-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>应用程序安全性可以归结为差不多两个独立的问题：身份验证（你是谁？）和授权（你可以做什么？）。</p><p>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p><h4 id="身份认证和访问控制"><a href="#身份认证和访问控制" class="headerlink" title="身份认证和访问控制"></a>身份认证和访问控制</h4><h5 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h5><p>认证策略的核心接口是 <code>AuthenticationManager</code> 。</p><pre class=" language-JAVA"><code class="language-JAVA">public interface AuthenticationManager {  Authentication authenticate(Authentication authentication)    throws AuthenticationException;}</code></pre><p><code>AuthenticationManager</code> 最常用的实现是 <code>ProviderManager</code>，它委托给一个<code>AuthenticationProvider</code> 实例链。 <code>AuthenticationProvider</code>有点像<code>AuthenticationManager</code>，但它有一个额外的方法来允许调用者询问它是否支持给定的认证类型。</p><p>，AuthenticationManager 接口的常用实现类 ProviderManager 内部会维护一个 List<authenticationprovider> 列表，存放多种认证方式。ProviderManager 中的 List，会依照次序去认证，认证成功则立即返回，若认证失败则返回 null，下一个AuthenticationProvider 会继续尝试认证，如果所有认证器都无法认证成功，则 ProviderManager 会抛出一个 ProviderNotFoundException 异常。</authenticationprovider></p><p>ProviderManager是Authentication的一个实现，并将具体的认证操作委托给一系列的AuthenticationProvider来完成，从而可以实现支持多种认证方式。为了帮助阅读和理解源码具体做了什么，这里删除了原来的一部分注释，并对重要的部分进行了注释说明。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AuthenticationProvider</span> <span class="token punctuation">{</span>    Authentication <span class="token function">authenticate</span><span class="token punctuation">(</span>Authentication var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> AuthenticationException<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>supports()</code> 方法中的<code>Class &lt;?&gt;</code>参数实际上是 <code>Class&lt;? extends Authentication&gt;</code>（它只会被问到是否支持将被传递到 <code>authenticate()</code> 方法的东西）。 一个 <code>ProviderManager</code> 可以通过委托给一个 <code>AuthenticationProviders</code> 链来支持同一个应用程序中的多个不同认证机制。 如果一个 ProviderManager 不能识别一个特定的 <code>Authentication</code> 类型，它将被跳过。</p><p><code>ProviderManager</code> 可以有一个父类认证器，如果所有的提供者返回null，则将再交给父类去认证。 如果父类不可用，则会导致 <code>AuthenticationException</code>。</p><p>有时应用程序具有受保护资源的逻辑组（例如所有与路径模式/ api / **相匹配的Web资源），并且每个组可以具有其自己的专用 <code>AuthenticationManager</code>。 通常，每个人都是一个 <code>ProviderManager</code>，他们共享一个父类。 父母是一种“全局”资源，充当所有提供者的失败回调。</p><p>Spring Security 提供了一些配置帮助类来快速获得应用程序中设置的通用身份验证管理器功能。 最常用的帮助类是 <code>AuthenticationManagerBuilder</code>，它非常适用于设置内存，JDBC或LDAP 中的用户详细信息，或添加自定义的<code>UserDetailsService</code>。 以下是配置全局（父类）<code>AuthenticationManager</code>的应用程序示例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationSecurity</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// web stuff here</span>  <span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">public</span> <span class="token function">initialize</span><span class="token punctuation">(</span>AuthenticationManagerBuilder builder<span class="token punctuation">,</span> DataSource dataSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>    builder<span class="token punctuation">.</span><span class="token function">jdbcAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withUser</span><span class="token punctuation">(</span><span class="token string">"dave"</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">password</span><span class="token punctuation">(</span><span class="token string">"secret"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">roles</span><span class="token punctuation">(</span><span class="token string">"USER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><p>授权核心策略是 <code>AccessDecisionManager</code>， 框架提供了三个实现，并将所有三个委托连接到一个 <code>AccessDecisionVoter</code> 链。</p><p>对象在 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 的签名中是完全通用的 - 它表示用户可能想要访问的任何内容。</p><p><code>ConfigAttributes</code> 也是相当通用的，用一些元数据表示安全对象的装饰，这些元数据决定了访问它所需的权限级别。</p><p>Spring Security 作为一个单独的过滤器安装在链中，其配置类型为 <code>FilterChainProxy</code>。</p><p>在Spring Boot应用程序中，安全过滤器是ApplicationContext中的<code>@Bean</code>，并具有默认配置，以便将其应用于每个请求。它被安装在由 <code>SecurityProperties.DEFAULT_FILTER_ORDER</code> 定义的位置，而该位置又由<code>FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>（Spring Boot应用程序在包装请求时修改其行为的期望过滤器的最大顺序）决定。</p><p><img src="/images/security-filters.png" alt="1"></p><h5 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h5><h6 id="SecurityContextHolder-SecurityContext和Authentication-对象"><a href="#SecurityContextHolder-SecurityContext和Authentication-对象" class="headerlink" title="SecurityContextHolder, SecurityContext和Authentication 对象"></a>SecurityContextHolder, SecurityContext和Authentication 对象</h6><p>最根本的对象是<code>SecurityContextHolder，应用程序的当前安全环境的细节存储到它里边，它也包含了应用当前使用的主体细节。默认情况下</code>SecurityContextHolder<code>使用</code>ThreadLocal存储这些信息，这意味着，安全环境在同一个线程执行的方法一直是有效的， 即使这个安全环境没有作为一个方法参数传递到那些方法里。</p><h5 id="FILTER"><a href="#FILTER" class="headerlink" title="FILTER"></a>FILTER</h5><pre><code>UsernamePasswordAuthenticationFilter</code></pre><p>在Spring Security中,保存<code>SecurityContext</code>的任务落在了<code>SecurityContextPersistenceFilter</code>身上，</p><h4 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h4><h5 id="创建Spring-Security的Java-配置类"><a href="#创建Spring-Security的Java-配置类" class="headerlink" title="创建Spring Security的Java 配置类"></a>创建Spring Security的Java 配置类</h5><ul><li><p>创建类SecurityConfiguration继承WebSecurityConfigurerAdapter，来对应用中所有的安全相关的事项（所有url，验证用户名密码，表单重定向等）进行控制，这个配置在你的应用程序中创建一个springSecurityFilterChain 的Servlet的过滤器。</p></li><li><p>@EnableWebSecurity 注解启用Web安全功能。</p></li><li><p>初始化springSecurityFilter注册类，继承类AbstractSecurityWebApplicationInitializer。</p><p>WebSecurityConfigurerAdapter共有三个configure方法</p></li></ul><pre><code>configure(WebSecurity) 通过重载，配置Spring Security的Filter链configure(HttpSecurity) 通过重载，配置如何通过拦截器保护请求configure(AuthenticationManagerBuilder) 通过重载，配置user-detail服务</code></pre><h5 id="密码加密策略"><a href="#密码加密策略" class="headerlink" title="密码加密策略"></a>密码加密策略</h5><ul><li><p>NoOpPasswordEncoder 明文方式保存</p></li><li><p>BCtPasswordEncoder 强hash方式加密</p></li><li><p>StandardPasswordEncoder SHA-256方式加密</p></li><li><p>实现PasswordEncoder接口,自定义加密方式</p><p>通过方法passwordEncoder传入对应的加密实例即可。</p></li></ul><h5 id="请求拦截策略"><a href="#请求拦截策略" class="headerlink" title="请求拦截策略"></a>请求拦截策略</h5><p>spring security的请求拦截匹配有两种风格，ant风格和正则表达式风格。编码方式是通过重载configure(HttpSecurity)方法实现。</p><pre><code>access(String)     如果给定的SpEL表达式计算结果为true，就允许访问anonymous()        允许匿名用户访问authenticated()    允许认证过的用户访问denyAll()          无条件拒绝所有访问fullyAuthenticated()   如果用户是完整认证的话（不是通过Remember-me功能认证的），就允许访问hasAnyAuthority(String...)   如果用户具备给定权限中的某一个的话，就允许访问hasAnyRole(String...)   如果用户具备给定角色中的某一个的话，就允许访问hasAuthority(String)   如果用户具备给定权限的话，就允许访问hasIpAddress(String)   如果请求来自给定IP地址的话，就允许访问hasRole(String)   如果用户具备给定角色的话，就允许访问not()   对其他访问方法的结果求反permitAll()   无条件允许访问rememberMe()   如果用户是通过Remember-me功能认证的，就允许访问</code></pre><h5 id="remember-me功能"><a href="#remember-me功能" class="headerlink" title="remember-me功能"></a>remember-me功能</h5><p>未完待续</p><h5 id="防止CSRF"><a href="#防止CSRF" class="headerlink" title="防止CSRF"></a>防止CSRF</h5><p>未完待续</p><h5 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h5><p>未完待续</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/76bfa6743ba9" target="_blank" rel="noopener">spring security 入门教程 简书</a></p><p><a href="http://www.spring4all.com/article/554" target="_blank" rel="noopener">Spring 官方教程：Spring Security 架构</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> spring security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker开发指南阅读总结</title>
      <link href="/2019/02/25/docker-kai-fa-zhi-nan-yue-du-zong-jie/"/>
      <url>/2019/02/25/docker-kai-fa-zhi-nan-yue-du-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>容器是轻量且可移植的仓库，包含应用程序及其依赖的组件。</p><p>容器中主进程运行多久，容器就运行多久。</p><p>Docker容器使用联合文件系统(union file system, UFS)，它允许多个文件系统以层级方式挂载，并表现为一个单一的文件系统。镜像的文件系统以只读的方式挂载，任何对运行中容器的改变则只会发生在它之上的可读写层。</p><p>Dockerfile里的每个指令都会创建一个新的层，而这个层将位于前一个层之上。由于不必要的层会使镜像变得臃肿，因此Dockerfile会把多个UNIX命令放在同一个RUN指令中，以减少层的数量。</p><p>数据卷是直接在主机挂载的文件或目录，不属于常规联合文件系统的一部分，它们允许与其他容器共享，而任何修改都会直接发生在主机的文件系统里。声明一个目录为数据卷有两种方法,第一种是在Dockerfile 里使用VOLUME 指令,第二种是在执行docker run 的时候使用-v 参数, 执行docker run 命令的时候可以指定用于挂载的主机目录。</p><p>一个常用的做法是创建数据容器，这种容器的唯一目的就是与其他容器分享数据，没有必要让数据容器一直运行。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p>docker run </p><p> -it  以交互的方式运行容器</p><p> -h  设定一个新的主机名</p><p> –rm 当容器退出时，容器和相关的文件系统会被一并删掉</p><p> –link 把容器连接起来(不推荐使用)</p><p>  -v HOST_DIR:CONTAINER_DIR</p><p>  -p: 指定端口映射，格式为：主机(宿主)端口:容器端口</p><p>docker diff  (容器的名称或ID) 查看有哪些文件被改动过</p><p>docker inspect (容器的名称或ID) 获取更多关于容器的信息</p><p>docker logs (容器的名称或ID)  得知这个容器里曾经发生过的一切事情</p><p>docker commit 将容器转为镜像(无论是在运行状态还是停止状态)</p><p>docker search 搜索已有的镜像</p><p>docker push 推镜像到仓库中</p><p>docker rm 删除一个或多个容器</p><p>  -v 删除与容器关联的卷(不是绑定挂载，或正被其他容器使用)</p><p>  -l 移除容器间的网络连接,而非容器本身</p><p>  -f 通过SIGKILL信号强制删除一个正在运行的容器</p><p>docker ps 列出正在运行容器</p><p>  -a 显示所有的容器,包括未运行的</p><p>  -f 根据条件过滤显示的内容(条件为指定,不在此列出,使用时可进行查询)</p><p>  –format 指定返回值的模板文件</p><p>  -l 显示最后被创建的容器</p><p>  -n 列出最近创建的n个容器</p><p>  –no-trunc 不截断输出,显示完整输出</p><p>  -q 静默模式,只显示容器编号</p><p>  -s 显示总的文件大小</p><p>docker pause  暂停容器中所有的进程。</p><p>docker unpause  恢复容器中所有的进程。</p><p>docker history 查看组成镜像的所有层</p><p>docker attach 允许用户查看容器内的主进程，与它进行交互</p><p>docker cp 在容器和主机之间复制文件和目录</p><p>docker exec 在容器中执行一个命令，用于执行维护工作</p><h4 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h4><p>docker ps -aq -f status=exited 得到所有已停止容器的id。</p><p>docker rm -v $(docker ps -aq -f status=exited) 删除所有已停止的容器。</p><p>docker run –restart on-failure:5 当退出值为非0时，将尝试重启5次，之后便会放弃。</p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>Dockerfile 是一个描述如何创建Docker 镜像所需步骤的文本文件。</p><p>所有Dockerfile 一定要有FROM 指令作为第一个非注释指令，FROM 指令指定初始镜像。</p><p>RUN 命令指定在镜像中运行的shell命令。</p><p>ENTRYPOINT 指令让我们指定一个可执行文件，同时还能处理传给docker run 的参数。</p><h4 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h4><h5 id="Docker系统架构"><a href="#Docker系统架构" class="headerlink" title="Docker系统架构"></a>Docker系统架构</h5><p><img src="/images/docker_structure.png" alt="1551711321388"></p><p>1.Docker 守护进程，它负责容器的创建、运行和监控，还负责镜像的构建和储存 ，容器和镜像都在图的右边。</p><p>2.Docker 客户端在图的左边，它通过HTTP 与Docker 守护进程通信，值得一提的是，Docker 客户端和守护进<br>程是由同一个二进制文件发布的。</p><p>3.Docker 寄存服务负责储存和发布镜像。</p><h5 id="镜像生成"><a href="#镜像生成" class="headerlink" title="镜像生成"></a>镜像生成</h5><p>docker build命令需Dockerfile和构建环境的上下文。</p><p>上下文是一组本地文件和目录，它可以被Dockerfile 的 ADD 或 COPY 指令所引用，通常以目录路径的形式指定。</p><p>从构建环境的上下文中排除不必要的文件，可以使用 .dockerignore 文件。</p><pre class=" language-XML"><code class="language-XML">当构建失败时，可以把失败前的那个层启动起来，这非常有助于调试。如果需要使缓存失效，可以在执行docker build 的时候加上--no-cache 参数。不同的镜像会共享相同的基础镜像层，</code></pre><h6 id="Dockerfile-的指令"><a href="#Dockerfile-的指令" class="headerlink" title="Dockerfile 的指令"></a>Dockerfile 的指令</h6><p>Dockerfile 的注释方法是以# 作为一行的开头。</p><p>1.ADD 从构建环境的上下文或远程URL 复制文件至镜像。</p><p>2.CMD 当容器启动时执行指定的指令。</p><p>3.COPY 用于从构建环境的上下文复制文件至镜像。</p><p>4.ENTRYPOINT 设置一个于容器启动时运行的可执行文件（以及默认参数）</p><p>5.ENV 设置镜像内的环境变量。</p><p>6.EXPOSE 向Docker 表示该容器将会有一个进程监听所指定的端口。</p><p>7.FROM 设置Dockerfile 使用的基础镜像。</p><p>8.MAINTAINER 通常用于设置镜像维护者的姓名和联系方式。</p><p>9.ONBUILD 指定当镜像被用作另一个镜像的基础镜像时将会执行的指令。</p><p>10.RUN 在容器内执行指定的指令，并把结果保存下来。</p><p>11.USER 设置任何后续的RUN、CMD 或ENTRYPOINT 指令执行时所用的用户（用户名或UID）</p><p>12.VOLUME 指定为数据卷的文件或目录。</p><p>13WORKDIR 对任何后续的RUN、CMD、ENTRYPOINT、ADD 或COPY 指令设置工作目录。</p><h5 id="通过compose实现容器自动化"><a href="#通过compose实现容器自动化" class="headerlink" title="通过compose实现容器自动化"></a>通过compose实现容器自动化</h5><p>Compose将使我们免于自己维护用于服务编排的脚本，包括启动、连接、更新和停止容器。</p><p>使用Compose常用的命令</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">up</span><span class="token punctuation">:</span>  启动所有在Compose 文件中定义的容器，并且把它们的日志信息汇集一起。通常会使用<span class="token punctuation">-</span>d 参数使Compose 在后台运行。<span class="token key atrule">build</span><span class="token punctuation">:</span> 重新建造由Dockerfile 构建的镜像。除非镜像不存在，否则up 命令不会执行构建的动作，因此需要更新镜像时便使用这个命令。<span class="token key atrule">ps</span><span class="token punctuation">:</span> 获取由Compose管理的容器的状态信息。<span class="token key atrule">run</span><span class="token punctuation">:</span> 启动一个容器，并运行一个一次性的命令。被连接的容器会同时启动，除非用了<span class="token punctuation">-</span><span class="token punctuation">-</span>nodeps参数。<span class="token key atrule">logs</span><span class="token punctuation">:</span> 汇集由Compose管理的容器的日志，并以彩色输出。<span class="token key atrule">stop</span><span class="token punctuation">:</span> 停止容器，但不会删除它们。<span class="token key atrule">rm</span><span class="token punctuation">:</span> 删除已停止的容器。不要忘记使用<span class="token punctuation">-</span>v 参数来删除任何由Docker 管理的数据卷。</code></pre><h5 id="镜像分发"><a href="#镜像分发" class="headerlink" title="镜像分发"></a>镜像分发</h5><p>从Dockerfile重新构建、从寄存服务器下载，或通docker load命令从归档文件安装。</p><p>待续。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven实战阅读总结</title>
      <link href="/2019/02/17/maven-shi-zhan-yue-du-zong-jie/"/>
      <url>/2019/02/17/maven-shi-zhan-yue-du-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Maven不仅是构建工具，还是一个依赖管理工具和项目信息管理工具，约定优于配置。</p><p>Maven会自动解析所有项目的直接依赖和传递性依赖，对于一些依赖冲突，也能进行调节，以确保任何一个构建只有唯一的版本在依赖中存在，最后得到的依赖被称为已解析依赖。</p><p>坐标和依赖是任何一个构件在Maven世界中的逻辑表示方式；构件的物理表示方式是文件，Maven通过仓库来统一管理这些文件。</p><p>对于Maven来说，基于发布版本，同样的坐标和版本意味着同样的构建，若本地仓库包含，则不会对照远程仓库进行更新。快照版本会根据时间戳对比，找到最新文件，快照版本只在组织内部或模块之间的依赖使用。</p><p>Maven还有两个核心概念是声明周期和插件。Maven声明周期是抽象的，其实际行为由插件来完成，两者协同工作，密不可分。</p><p>Maven的聚合特性能将项目的各个模块聚合在一起构建，继承特性能抽取各模块相同的依赖和插件等配置，保持各个模块的一致性。</p><h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>Maven依赖管理的底层基础是坐标，一组Maven坐标是通过一些元素来定义的，他们是groupId，artifactId，version，packaging，classifier(用来帮助定义构建输出的一些附属构件，与主构件对应，不能直接定义项目的classifier)。</p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><h5 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h5><p>依赖范围用来控制依赖于编译、测试、运行这三种classpath的关系。</p><p>依赖传递时的关系如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围。</p><p><img src="/images/scope.jpg" alt=""></p><h5 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h5><p>当依赖冲突时，Maven依赖调解的第一原则是:路径最近着优先；第二原则是第一生命者优先。</p><h5 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h5><p>声明如下。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.46<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>根据单一职责性原则，在理想情况下，不应该使用可选项依赖。</p><h4 id="mvn-dependency"><a href="#mvn-dependency" class="headerlink" title="mvn dependency"></a>mvn dependency</h4><h5 id="mvn-dependency-list"><a href="#mvn-dependency-list" class="headerlink" title="mvn dependency : list"></a>mvn dependency : list</h5><p>显示所有已解析依赖，同时，每个依赖的范围也得以明确标识。</p><h5 id="mvn-dependency-tree"><a href="#mvn-dependency-tree" class="headerlink" title="mvn dependency : tree"></a>mvn dependency : tree</h5><p>查看当前项目的依赖树。</p><h5 id="mvn-dependency-analyze"><a href="#mvn-dependency-analyze" class="headerlink" title="mvn dependency : analyze"></a>mvn dependency : analyze</h5><p>帮助分析当前项目的依赖。</p><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>Maven仓库是基于简单文件系统存储的，路径与坐标的大致对应关系为groupId/artifactId/version/artifactId-version.packaging.</p><p>Maven仓库的分类如下图所示。</p><p><img src="/images/maven-%E4%BB%93%E5%BA%93%E5%88%86%E7%B1%BB.jpg" alt=""></p><p>自定义本地仓库目录的地址</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- setting.xml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localRepository</span><span class="token punctuation">></span></span>E://maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localRepository</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>setting</span><span class="token punctuation">></span></span></code></pre><p>远程仓库配置(可直接配置在pom文件中)</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repositories</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repository</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 任何一个仓库的ID必须是唯一的 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>jboss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>JBoss Repository<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 仓库的地址 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://repository.jboss.com/maven2/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 表示仓库布局是Maven2和Maven3的默认布局 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>releases</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enabled</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>enabled</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 从远程仓库检查更新的频率(每隔3分钟检查一次)--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>updatePolicy</span><span class="token punctuation">></span></span>interval: 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>updatePolicy</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 检查文件的策略(遇到校验错误构建失败) --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>checksumPolicy</span><span class="token punctuation">></span></span>fail<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>checksumPolicy</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>releases</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>snapshots</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enabled</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>enabled</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>snapshots</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repository</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repositories</span><span class="token punctuation">></span></span></code></pre><p>远程仓库认证</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- setting.xml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servers</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>server</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!-- id与需要认证的repository元素的id保持一致 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>jboss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span>repouser<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>repopwd<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>server</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servers</span><span class="token punctuation">></span></span></code></pre><p>将项目生成的构建部署到仓库中</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span><span class="token punctuation">></span></span>    ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>distributionManagement</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 发布版本的仓库 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repository</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>releases<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>${releases.repo}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repository</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 快照版本的仓库 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>snapshotRepository</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>snapshots<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>${snapshots.repo}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>snapshotRepository</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>distributionManagement</span><span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。关于镜像更为常见的做法是结合私服，这可以将仓库配置集中到私服，私服就是所有仓库的镜像，简化Maven本身的配置。</p><p>当镜像仓库不稳定或无法提供服务时，仍将无法访问被镜像仓库。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrors</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>mirrorId<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Human Readable Name for this Mirror.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://my.repository.com/repo/path<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrors</span><span class="token punctuation">></span></span></code></pre><p><img src="/images/mirrors.jpg" alt=""></p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Maven生命周期就是为了对所有构建过程进行抽象和统一，包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署，和站点生成等几乎所有的构建步骤，但生命周期本身不做任何实际的工作。</p><p>根据插件机制，每个构建步骤可以绑定一个或多个插件行为。</p><p>Maven有三套独立的生命周期：clean(清理项目)、default（构建项目）、site(建立项目站点)。</p><p><img src="/images/clean.jpg" alt=""></p><p><img src="/images/site.jpg" alt=""></p><p><img src="/images/default.jpg" alt=""></p><p>每个生命周期是相互独立的，但一个生命周期的阶段是有前后依赖关系的。</p><h4 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h4><p>一个插件里的每个功能就是一个插件目标，例如maven-dependency-plugin插件能分别对应的目标为dependency:tree,dependency:list,dependency:analyze等，这是一种通用写法，冒号前面是插件，冒号后面是该插件的目标。</p><h4 id="自定义绑定"><a href="#自定义绑定" class="headerlink" title="自定义绑定"></a>自定义绑定</h4><p>用户自己选择将某个插件目标绑定到生命周期的某个阶段上。</p><p>在bulid元素下的plugins子元素中声明插件的使用。</p><p><a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="noopener">Maven在线插件文档</a></p><p>在pom中定义插件时，如果是Maven的官方插件，可以省略掉groupId，Maven内部插件解析机制会进行处理。</p><h4 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h4><h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><p><img src="/images/aggreate.jpg" alt=""></p><p>packing值为pom，且配置modules。</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p><img src="/images/extend.png" alt="1550760187230"></p><p>可继承的POM元素</p><p>groupId：项目组ID，项目坐标的核心元素。</p><p>version：项目版本，项目坐标的核心元素。</p><p>description：项目的描述信息。</p><p>organization：项目的组织信息。</p><p>inceptionYear：项目的创始年份。</p><p>url：项目的URL地址。</p><p>developers：项目的开发者信息。</p><p>contributors：项目的开发者信息。</p><p>distributionManagement：项目的部署配置。</p><p>issueManagement：项目的缺陷跟踪系统信息。</p><p>ciManagement：项目的持续集成系统信息。</p><p>scm：项目的版本控制系统信息。</p><p>mailingLists：项目的邮件列表信息。</p><p>properties：自定义的Maven属性。</p><p>dependencies：项目的依赖配置。</p><p>dependencyManagement：项目的依赖管理配置。</p><p>repositories：项目的仓库配置。</p><p>build：包括项目的源码目录配置：输出目录配置、插件配置、插件管理配置等。</p><p>reporting：包括项目的报告输出目录配置、报告插件配置等。</p><p>在dependencyManagement元素下的依赖不会引入实际的依赖，不过它能够约束dependencies下的依赖使用，子模块只需配置简单的groupId和artifactId就能引入正确的依赖。</p><p>import范围依赖可以导入另一pom中的dependencyManagement配置。</p><p><img src="/images/import.png" alt="1550763166979"></p><p>指向了打包类型为pom的模块。</p><h5 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h5><h5 id="反应堆"><a href="#反应堆" class="headerlink" title="反应堆"></a>反应堆</h5><p>即所有模块组成的构建结构，可以通过裁剪反应堆，指定构建顺序。</p><h4 id="Nexus"><a href="#Nexus" class="headerlink" title="Nexus"></a>Nexus</h4><p>nexus的关注点功能有:建立各种类型的仓库，权限管理功能，调度任务功能等。</p><h4 id="Maven测试"><a href="#Maven测试" class="headerlink" title="Maven测试"></a>Maven测试</h4><p>Maven的maven-surefire-plugin会自动自动执行测试源码路径中以<strong>Test</strong>开头和以<strong>Test</strong>或<strong>TestCase</strong>结尾的Java类。</p><p>maven-surefire-plugin是maven背后真正执行测试的插件。</p><p>cobertura-maven-plugin能生成测试覆盖率报告，mvn cobertura:cobertura.</p><h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><p>快速且高效率的<strong>自动</strong>构建项目的所有源码，并为项目成员提供丰富的反馈信息。</p><p>文中主要介绍的Hudson为Jenkins前身。</p><h4 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h4><p><img src="/images/version.png" alt="1551012419884"></p><p>主版本表示了项目的重大架构变更，次版本表示较大范围的功能增加和变化，增量版本表示重大bug的修复，里程碑版本表示某一版本的里程碑，但还不是非常稳定。</p><p>对于里程碑版本只是简单的字符串比较，一次会得到1.2-beta-3&gt;1.2-beta-11，这一点需要留意。</p><h5 id="Maven-Release-Plugin"><a href="#Maven-Release-Plugin" class="headerlink" title="Maven Release Plugin"></a>Maven Release Plugin</h5><p>此插件的目标:prepare,rollback,perform,branch。</p><h5 id="项目的scm信息配置"><a href="#项目的scm信息配置" class="headerlink" title="项目的scm信息配置"></a>项目的scm信息配置</h5><p><img src="/images/scm.png" alt="1551013437812"></p><p>connection表示只读的scm地址，url表示浏览器中访问的地址，developerConnection表示可写的地址。</p><h4 id="灵活的构建"><a href="#灵活的构建" class="headerlink" title="灵活的构建"></a>灵活的构建</h4><h5 id="Maven属性"><a href="#Maven属性" class="headerlink" title="Maven属性"></a>Maven属性</h5><p>内置属性，POM属性，自定义属性，setting属性，java系统属性和环境变量属性。</p><h5 id="资源过滤"><a href="#资源过滤" class="headerlink" title="资源过滤"></a>资源过滤</h5><p><img src="/images/resources.png" alt="1551016659519"></p><p>目的为Maven解析资源文件中的Maven属性，进行替换。</p><h4 id="编写maven插件"><a href="#编写maven插件" class="headerlink" title="编写maven插件"></a>编写maven插件</h4><p>步骤如下:</p><p>​    1.创建maven项目，packing为maven-plugin；</p><p>​    2.为插件编写目标(MoJo),必须继承自AbstractMoJo，并实现execute方法;</p><p>​    3.为目标提供配置点(@parameter)；</p><p>​    4.编写代码实现目标行为；</p><p>​    5.错误处理及日志；</p><p>​    6.测试插件。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea好用的快捷键</title>
      <link href="/2019/01/27/idea-hao-yong-de-kuai-jie-jian/"/>
      <url>/2019/01/27/idea-hao-yong-de-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h5 id="定位到类的位置"><a href="#定位到类的位置" class="headerlink" title="定位到类的位置"></a>定位到类的位置</h5><p>使用<code>alt+F1</code>，弹出<code>Select in</code>视图，然后选择<code>Project View</code>，回车。</p><h5 id="使用快捷键移动分割线"><a href="#使用快捷键移动分割线" class="headerlink" title="使用快捷键移动分割线"></a>使用快捷键移动分割线</h5><p><code>alt+1</code>把鼠标焦点定位到<code>project</code>视图里，然后直接使用<code>ctrl+shift+左右箭头</code>来移动分割线。</p><h5 id="取消单行显示tabs的操作"><a href="#取消单行显示tabs的操作" class="headerlink" title="取消单行显示tabs的操作"></a>取消单行显示tabs的操作</h5><p><img src="/images/1.jpg" alt="1"></p><h5 id="滚轴修改字体大小"><a href="#滚轴修改字体大小" class="headerlink" title="滚轴修改字体大小"></a>滚轴修改字体大小</h5><p><img src="/images/2.jpg" alt="2"></p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://www.iocoder.cn/tags/IntelliJ-IDEA/" target="_blank" rel="noopener">芋道源码-idea</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钗头凤</title>
      <link href="/2018/12/31/chai-tou-feng/"/>
      <url>/2018/12/31/chai-tou-feng/</url>
      
        <content type="html"><![CDATA[<h2 id="钗头凤·红酥手-陆游"><a href="#钗头凤·红酥手-陆游" class="headerlink" title="钗头凤·红酥手   陆游"></a>钗头凤·红酥手   陆游</h2><p>红酥手，黄縢酒。满城春色宫墙柳。东风恶，欢情薄。一杯愁绪，几年离索。错、错、错。 </p><p>春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫。</p><h2 id="钗头凤·世情薄-唐氏"><a href="#钗头凤·世情薄-唐氏" class="headerlink" title="钗头凤·世情薄   唐氏"></a>钗头凤·世情薄   唐氏</h2><p>世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残，欲笺心事，独语斜阑。难，难，难！</p><p>人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊，怕人寻问，咽泪装欢。瞒，瞒，瞒！​      ​               </p><pre><code>说不完的离愁，诉不尽的相思。        世人皆苦，唯心不易。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo博客的搭建</title>
      <link href="/2019/11/27/hexo-bo-ke-de-da-jian/"/>
      <url>/2019/11/27/hexo-bo-ke-de-da-jian/</url>
      
        <content type="html"><![CDATA[<p>本文旨在讲述个人使用hexo及GithubPages搭建的过程。</p><p>主要参考<a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener">最全Hexo博客搭建+主题优化+插件配置+常用操作+错误分析</a>。</p><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>经对比, 选择<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>, demo为<a href="https://blinkfox.github.io/" target="_blank" rel="noopener">闪烁之狐</a>, 贼拉好看。</p><ul><li><p>下载主题至themes文件夹下, 然后修改<code>_config.yml</code>的theme字段为主题文件夹名称。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">theme</span><span class="token punctuation">:</span> hexo<span class="token punctuation">-</span>theme<span class="token punctuation">-</span>matery</code></pre></li><li><p>根据<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">readme配置文件</a>做进一步配置。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flyway的学习</title>
      <link href="/2019/11/21/flyway-de-xue-xi/"/>
      <url>/2019/11/21/flyway-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>数据库可以像代码一样, 使用flyway进行良好的版本控制。</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h5 id="空数据库-最简单的方式"><a href="#空数据库-最简单的方式" class="headerlink" title="空数据库-最简单的方式"></a>空数据库-最简单的方式</h5><ul><li><p>flyway找不到<code>schema history table</code>时, 将创建默认名为<code>flyway_schema_history</code>的表。</p></li><li><p>flyway随后会扫描文件系统或application的classpath, 找到对应文件进行<code>migrations</code>。其可以是sql或java编写。</p></li><li><p>每次migration生效后, <code>flyway_schema_history</code>中会生成一条记录。</p><p><img src="/images/flyway_schema_history.jpg" alt="flyway_schema_history"></p></li><li><p>每次创建一个版本更高的<code>migration</code>, 当下次flyway运行时, 其将会找到并运行该<code>migration</code>来升级数据库。</p></li></ul><h5 id="非空数据库"><a href="#非空数据库" class="headerlink" title="非空数据库"></a>非空数据库</h5><p>指定baseline。</p><ul><li>baselineOnMigrate  是否开启baseline, 默认为false。</li><li>baselineVersion 高于该指定版本的才会进行migrate。</li><li>baselineDescription 描述。</li></ul><pre class=" language-shell"><code class="language-shell">flyway -baselineOnMigrate=true -baselineVersion=1 -baselineDescription="aaa" migrate</code></pre><h5 id="command-line"><a href="#command-line" class="headerlink" title="command-line"></a>command-line</h5><p>以此种方式为例进行说明。</p><ul><li><p>下载对应系统的flyway command-line tool。</p></li><li><p>进入到flyway文件夹。</p><pre class=" language-shell"><code class="language-shell">cd flyway-6.0.8</code></pre></li><li><p>配置./conf/flyway.conf</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">flyway.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/flyway?serverTimezone=UTC</span><span class="token attr-name">flyway.user</span><span class="token punctuation">=</span><span class="token attr-name">flyway.password</span><span class="token punctuation">=</span></code></pre></li><li><p>在./sql目录下添加sql文件, 命名为<code>V1__Create_person_table.sql</code>, <font color="red">注意V1后的下划线为两个</font>, V是version的缩写, 1为版本号, __后的为此次操作的描述。</p></li><li><p>执行flyway migrate, 即可在数据库看到改变。</p><pre class=" language-sh"><code class="language-sh">flyway-6.0.8> flyway migrate</code></pre></li></ul><p>还可通过API、maven、Gradle来实现, 其具体操作参见官方文档。</p><h5 id="Repeatable-Migrations"><a href="#Repeatable-Migrations" class="headerlink" title="Repeatable Migrations"></a>Repeatable Migrations</h5><p>命名规则: <code>R__people_view.sql</code>, 即使用<code>R</code>代替<code>V</code>,并且无需指定版本号, 其总是最后生效, 且可保证多次重复执行。一般用于创建 views/procedures/functions/packages/…</p><h5 id="Undo-Migrations"><a href="#Undo-Migrations" class="headerlink" title="Undo Migrations"></a>Undo Migrations</h5><p>命名规则: <code>U2__Add_people.sql</code>, U代替V, 其基于之前的migration均是成功的, 不能undo失败的migration。</p><p>当存在migration失败时, 需人工介入。</p><p>社区版不支持, 算了, 不用了。</p><h5 id="Dry-Runs"><a href="#Dry-Runs" class="headerlink" title="Dry Runs"></a>Dry Runs</h5><p>社区版不支持, 可生成该次会执行的sql改动, 便于检查。</p><h4 id="SQL-based-migrations"><a href="#SQL-based-migrations" class="headerlink" title="SQL-based migrations"></a>SQL-based migrations</h4><h5 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h5><p><img src="/images/flyway-naming.png" alt="flyway-naming"></p><p>Versioned可以省略Separator和Description(最好不要)。</p><h5 id="Discovery"><a href="#Discovery" class="headerlink" title="Discovery"></a>Discovery</h5><p>文件可以在filesystem或classpath, 分别使用对应的前缀, 即<code>filesystem:</code>或<code>classpath:</code>。</p><h5 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h5><p>flyway支持sql语义, 一行或多行语句。</p><p>单行注释(–)或多行注释(/**/)。</p><p>指定数据库的语义延伸。</p><h5 id="Placeholder-Replacement"><a href="#Placeholder-Replacement" class="headerlink" title="Placeholder Replacement"></a>Placeholder Replacement</h5><p>flyway支持占位符。</p><h4 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h4><p>7个命令: Migrate, Clean, Info, Validate, Undo, Baseline, Repair。</p><h5 id="Migrate"><a href="#Migrate" class="headerlink" title="Migrate"></a>Migrate</h5><p>flyway的中心功能, 其会扫描filesystem和classpath寻找可用的migration, 并与数据库里flyway_schema_history的版本进行比较, 执行需要执行的migration。</p><p>在启动时来执行migration, 避免数据库与代码的不一致。</p><h5 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h5><p><font color="red">在开发和测试环境很有用, 但不要在生产环境使用。</font></p><p>删除所有表, 试图, 存储过程, 触发器等。</p><h5 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h5><p>查看migrations的详细信息, 即flyway_schema_history的表信息。</p><h5 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h5><p>校验可用的migration与已生效的migration。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://flywaydb.org/getstarted/" target="_blank" rel="noopener">flyway官网</a></p><p><a href="https://flywaydb.org/download/" target="_blank" rel="noopener">下载地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gRPC的学习</title>
      <link href="/2019/11/20/grpc-de-xue-xi/"/>
      <url>/2019/11/20/grpc-de-xue-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>gRPC为Google的rpc实现, 使用proto buffer作为接口定义语言(Interface Definition Language, 即IDL)。</p><p>客户端可以像调用本地方法一样调用服务端方法。</p><p>在客户端保存有接口存根来进行方法调用，该存根有和服务器同样的方法; 服务端实现接口定义的方法, 来处理客户端的请求。</p><p> <img src="/images/grpc-model.svg" alt="Concept Diagram"></p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><h5 id="Service-definition"><a href="#Service-definition" class="headerlink" title="Service definition"></a>Service definition</h5><p>使用proto buffer定义接口(可以使用其它可选择的协议代替proto buffer)。</p><pre class=" language-protobuf"><code class="language-protobuf">service HelloService <span class="token punctuation">{</span>  rpc <span class="token function">SayHello</span> <span class="token punctuation">(</span>HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>HelloResponse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">message</span> HelloRequest <span class="token punctuation">{</span>  <span class="token primitive symbol">string</span> greeting <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">message</span> HelloResponse <span class="token punctuation">{</span>  <span class="token primitive symbol">string</span> reply <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>有四种接口方法</p><ul><li><p>像普通的函数,  一种请求类型, 一种返回类型。</p><pre class=" language-protobuf"><code class="language-protobuf">rpc <span class="token function">SayHello</span><span class="token punctuation">(</span>HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>HelloResponse<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>服务器返回流式数据, 在一次独立的调用中, gRPC保证其信息的顺序。</p><pre class=" language-protobuf"><code class="language-protobuf">rpc <span class="token function">LotsOfReplies</span><span class="token punctuation">(</span>HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>stream HelloResponse<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>客户端发送流式数据, 在一次独立的调用中, gRPC保证其信息的顺序。</p><pre class=" language-protobuf"><code class="language-protobuf">rpc <span class="token function">LotsOfGreetings</span><span class="token punctuation">(</span>stream HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>HelloResponse<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>双向流式数据, 请求流和返回流独立处理, 服务端可以接受完所有数据后再返回, 也可以边接受边回传数据。</p><p>在彼此的数据流中, 顺序得到保证。</p><pre class=" language-protobuf"><code class="language-protobuf">rpc <span class="token function">BidiHello</span><span class="token punctuation">(</span>stream HelloRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>stream HelloResponse<span class="token punctuation">)</span></code></pre></li></ul><h5 id="Synchronous-vs-asynchronous"><a href="#Synchronous-vs-asynchronous" class="headerlink" title="Synchronous vs asynchronous"></a>Synchronous vs asynchronous</h5><p>同步调用会阻塞，其也是RPC的方法调用希望的做法, 但是在很多场景下, 需要异步调用。</p><p>grpc同时支持同步编程和异步编程。</p><h5 id="RPC-life-cycle"><a href="#RPC-life-cycle" class="headerlink" title="RPC life cycle"></a>RPC life cycle</h5><h6 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h6><ul><li>客户端调用方法时, 服务端将会收到通知, 并得到这次调用客户端的 <a href="#Metadata">Metadata</a>, 方法名, 及如果指定了的<a href="#deadline">Deadlines</a>。</li><li>服务端也会立即返回自己的Metadata(必须在response前返回), 或者在收到请求信息后。</li><li>服务端进行处理, 返回对应的数据, 包括状态码和状态信息等。</li><li>当此次请求成功时, 客户端得到返回, 一次调用结束。</li></ul><h6 id="Deadlines-Timeouts"><a href="#Deadlines-Timeouts" class="headerlink" title="Deadlines/Timeouts"></a><span id="deadline">Deadlines/Timeouts</span></h6><p>客户端可以指定超时时间,  当超时时，会返回<font color="red">DEADLINE_EXCEEDED</font>。</p><h6 id="RPC-termination"><a href="#RPC-termination" class="headerlink" title="RPC termination"></a>RPC termination</h6><p>客服端和服务端都可以决定一次调用什么时候结束。</p><p>当请求超过客户端设定的超时时间,  客户端会认定请求失败, 即使服务端随后成功处理并发送返回。</p><p>服务端也可以在客服端发送完请求数据前开始返回来完成这次请求。</p><h6 id="Cancelling-RPCs"><a href="#Cancelling-RPCs" class="headerlink" title="Cancelling RPCs"></a>Cancelling RPCs</h6><p>其不会<font color="red">undo</font>, 在撤销前的改变不会回滚。</p><h6 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a><span id="Metadata">Metadata</span></h6><p>键值对形式,  客户端通过metadata提供调用相关信息给服务端, 反之亦然。</p><h6 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h6><p>提供到指定地址的gRPC server的连接。</p><p>clients可以通过指定channel参数来修改gRPC的默认行为, 例如打开或关闭消息压缩。</p><p>channel有状态, 包括 <code>connected</code>  和 <code>idle</code>。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>gRPC支持多种认证机制。</p><ul><li>SSL/TLS</li><li>Token-based authentication with Google</li></ul><h5 id="Authentication-API"><a href="#Authentication-API" class="headerlink" title="Authentication API"></a>Authentication API</h5><h6 id="Credential-tpyes"><a href="#Credential-tpyes" class="headerlink" title="Credential tpyes"></a>Credential tpyes</h6><ul><li>Channel credentials</li><li>Call Credentials</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.grpc.io/docs/" target="_blank" rel="noopener">官方文档</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proto buffer 学习</title>
      <link href="/2019/11/14/proto-buffer-xue-xi/"/>
      <url>/2019/11/14/proto-buffer-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>protobuffer是与语言无关、与平台无关、可扩展的数据格式,  可用于数据通信及存储等, 比XML更小、更快、更简洁。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="定义proto-file"><a href="#定义proto-file" class="headerlink" title="定义proto file"></a>定义proto file</h4><pre class=" language-protobuf"><code class="language-protobuf">syntax <span class="token operator">=</span> <span class="token string">"proto3"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// this is request</span><span class="token keyword">message</span> SearchRequest <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// reserved filed number which cannot be used</span>  <span class="token builtin">reserved</span> <span class="token number">4</span><span class="token punctuation">;</span>      <span class="token builtin">optional</span> <span class="token primitive symbol">string</span> voice_box <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token builtin">required</span> <span class="token primitive symbol">int32</span> host <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token builtin">repeated</span> <span class="token primitive symbol">int32</span> display <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* this is response*/</span><span class="token keyword">message</span> SerachResponse <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><ul><li><p>第一行标识使用proto3语义， 如未在第一个非注释行指定, 则默认使用proto2。</p></li><li><p>每个filed有命名和类型, 类型可以是 numbers(整型或浮点型)、  booleans 、 strings 、enumerations、bytes, 甚至是proto buffer类型。proto字段类型与不同语言的对应关系: <a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">scalar value types</a>。</p></li><li><p>每个字段类型后都有一个唯一标识号, 此标识号会在proto二进制文件中使用, 标识号在1-15内使用一个字节去编码, 16至2047使用两个字节去编码, 故1-15为频繁使用的字段保留,  也应留存以便未来使用。</p></li><li><p><font style="color:red"> reserved, 保证不被后来的使用者重新使用</font></p></li><li><p>不能在.proto文件中使用19000-19999作为字段标识号, 因为它们是proto保留字段数。</p></li><li><p>使用//或/**/添加注释。</p></li><li><p>singular(optional 或 required): 至多1个, repeated: 不限制个数, 0或多个, 相对而言使用required弊多于利。</p></li></ul><h4 id="枚举字段"><a href="#枚举字段" class="headerlink" title="枚举字段"></a>枚举字段</h4><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">message</span> SearchRequest <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">enum</span> Corpus <span class="token punctuation">{</span>       <span class="token builtin">reserved</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">9</span> to <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">40</span> to max<span class="token punctuation">;</span>      option allow_alias <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    UNIVERSAL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    WEB <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    IMAGES <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    LOCAL <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    NEWS <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    PRODUCTS <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    VIDEO <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    START <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    BEGIN <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  Corpus corpus <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>必须有0值，此为默认值。</li><li>0值必须是第一个元素, 与proto2兼容(其默认第一个枚举值为默认值)。</li><li>allow_alias = true, 即允许在enum中使用别名,  即START与BEGIN。</li><li>可在其他message type中使用该enum, 即MessageType.EnumType。</li><li><font color="green">reserved, 保证不被后来的使用者重新使用</font></li></ul><h4 id="定义message-type-field"><a href="#定义message-type-field" class="headerlink" title="定义message type field"></a>定义message type field</h4><p>proto编译器找寻proto文件的路径通过命令行里的 -I/–proto_path指定, 如若不存在, 其在编译器执行的当前目录   下找寻。</p><ul><li><p>在同一proto文件中, 可直接使用。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">message</span> SearchResponse <span class="token punctuation">{</span>  <span class="token builtin">repeated</span> Result results <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">message</span> Result <span class="token punctuation">{</span>  <span class="token primitive symbol">string</span> url <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>在同一目录下的其他文件中,  需导入该proto文件。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">import</span> <span class="token string">"myproject/other_protos.proto"</span><span class="token punctuation">;</span></code></pre></li><li><p>非同一目录下,  使用import public</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">import</span> public <span class="token string">"new.proto"</span></code></pre></li></ul><h4 id="更新Message-Type"><a href="#更新Message-Type" class="headerlink" title="更新Message Type"></a>更新Message Type</h4><p> 注意事项:</p><ul><li>不要改动任何已存在的字段标识号。</li><li>添加新字段时, 应明确知晓其默认值, 以便新代码可以正常处理老proto生成的信息。</li><li>字段可以被删除, 但不能被再次使用, 可以将其置为<font color="blue">reserved</font>或添加<font color="blue"> OBSOLETE_ </font>前缀。</li></ul><h4 id="未知字段"><a href="#未知字段" class="headerlink" title="未知字段"></a>未知字段</h4><p>当老版本解析新版本中新增字段时，其新增字段属于未知字段。</p><p>版本3.5后, proto会保留未知字段, 而非丢弃。</p><h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><p>Any可以允许使用message tpye, 而不引入其proto文件。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">import</span> <span class="token string">"google/protobuf/any.proto"</span><span class="token punctuation">;</span><span class="token keyword">message</span> ErrorStatus <span class="token punctuation">{</span>    String <span class="token keyword">message</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token builtin">repeated</span> google<span class="token punctuation">.</span>protobuf<span class="token punctuation">.</span>Any details <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="oneof"><a href="#oneof" class="headerlink" title="oneof"></a>oneof</h4><p>每次最多只有一个字段类型被设置时, 可以使用oneof, 不能在oneof中使用repeated字段。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">message</span> SampleMessage <span class="token punctuation">{</span>  oneof test_oneof <span class="token punctuation">{</span>    <span class="token primitive symbol">string</span> name <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    SubMessage sub_message <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>设置oneof字段时, 如同时设置多个,  只有最后一个会被保留。</li><li>如果解析器同时发现多个相同的oneof, 只有最后一个oneof会被保留。</li><li>谨慎添加或删除oneof字段。</li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><pre class=" language-protobuf"><code class="language-protobuf"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// map&lt;key_type, value_type> map_field = N;</span>map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Project<span class="token operator">></span> projects <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><ul><li><p>key_type可以是int或string类型, enum、floating和enum不是有效的key_type。</p></li><li><p>value_type可以是任何类型, 但不能是map。</p></li><li><p>Map字段不能使repeated。</p><h5 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h5></li></ul><pre class=" language-protobuf"><code class="language-protobuf"><span class="token comment" spellcheck="true">// 此与map等价, 任何支持map的proto协议都必须接受如下定义。</span><span class="token keyword">message</span> MapFieldEntry <span class="token punctuation">{</span>  key_type key <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  value_type value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token builtin">repeated</span> MapFieldEntry map_field <span class="token operator">=</span> N<span class="token punctuation">;</span></code></pre><h4 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h4><p>可以在proto文件中使用package来防止名称冲突。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token keyword">package</span> foo<span class="token punctuation">.</span>bar<span class="token punctuation">;</span><span class="token keyword">message</span> Open <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><h4 id="Defining-Services"><a href="#Defining-Services" class="headerlink" title="Defining Services"></a>Defining Services</h4><p>在proto文件中定义rpc接口。</p><pre class=" language-protobuf"><code class="language-protobuf">service SearchService <span class="token punctuation">{</span>    rpc <span class="token function">Search</span> <span class="token punctuation">(</span>SearchRequest<span class="token punctuation">)</span> <span class="token function">returns</span> <span class="token punctuation">(</span>SearchResponse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="转为JSON"><a href="#转为JSON" class="headerlink" title="转为JSON"></a>转为JSON</h4><p><a href="https://developers.google.com/protocol-buffers/docs/proto3#json" target="_blank" rel="noopener">JSON Mapping</a></p><h4 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h4><ul><li><p>java_package, 如果不是生成java代码, 其不起作用。</p><pre class=" language-protobuf"><code class="language-protobuf">option java_package <span class="token operator">=</span> <span class="token string">"com.example.foo"</span><span class="token punctuation">;</span></code></pre></li><li><p>java_multiple_files, 将proto文件内定义的message type生成多个java类。</p><pre class=" language-protobuf"><code class="language-protobuf">option java_multiple_files <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre></li><li><p>java_outer_classname, 指定生成的java类名。</p><pre class=" language-protobuf"><code class="language-protobuf">option java_outer_classname <span class="token operator">=</span> <span class="token string">"Ponycopter"</span><span class="token punctuation">;</span></code></pre></li><li><p>optimize_for,  可用的值有三个，SPEED、CODE_SIZE、LITE_RUNTIME。默认为SPEED, 对于后台应用, 使用默认的即可。</p><pre class=" language-protobuf"><code class="language-protobuf">option optimize_for <span class="token operator">=</span> CODE_SIZE<span class="token punctuation">;</span></code></pre></li><li><p>deprecated,  对于java语言, 对应字段标注@Deprecated注解。</p><pre class=" language-protobuf"><code class="language-protobuf"><span class="token primitive symbol">int32</span> old_field <span class="token operator">=</span> <span class="token number">6</span> <span class="token punctuation">[</span>deprecated<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></li><li><p>还可以自定义options, 感兴趣可查看<a href="https://developers.google.com/protocol-buffers/docs/proto.html#customoptions" target="_blank" rel="noopener">custom options</a>。</p></li></ul><h4 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h4><pre class=" language-protobuf"><code class="language-protobuf">protoc <span class="token operator">--</span>proto_path<span class="token operator">=</span>IMPORT_PATH <span class="token operator">--</span>cpp_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>java_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>python_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>go_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>ruby_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>objc_out<span class="token operator">=</span>DST_DIR <span class="token operator">--</span>csharp_out<span class="token operator">=</span>DST_DIR path<span class="token operator">/</span>to<span class="token operator">/</span>file<span class="token punctuation">.</span>proto</code></pre><ul><li>proto_path, 指定proto文件所在位置, 可指定多次, -I是其简化写法。</li><li>java_out即可生成java代码, 其DST_DIR可指定为zip或jar, 则输出文件即为对应格式。</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="noopener">package download</a></p><p>找到对应系统的安装包:  protoc-$VERSION-$PLATFORM.zip, 下载解压后,  配置环境变量, 即可使用protoc生成类文件。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">protocol buffers overview</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">language guide(proto3)</a></p><p><a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">encoding</a></p><p><a href="https://www.cnblogs.com/dkblog/archive/2012/03/27/2419010.html" target="_blank" rel="noopener">Protobuf语言指南-很全-官方文档中文版</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> data-serialization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-菜鸟教程</title>
      <link href="/2019/05/19/python-cai-niao-jiao-cheng/"/>
      <url>/2019/05/19/python-cai-niao-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><ul><li><p>注释</p><p>以#开头, 或 ‘’’ 和 “””。</p></li><li><p>行与缩进</p><p>使用缩进来表示代码块, 同一个代码块的语句必须包含相同的缩进空格数。</p><p>缩进数的空格数不一致，会导致运行错误。</p></li><li><p>多行语句</p><p>语句很长，可以使用反斜杠\来实现多行语句。</p><pre class=" language-python"><code class="language-python">total <span class="token operator">=</span> item_one <span class="token operator">+</span> \        item_two <span class="token operator">+</span> \        item_three</code></pre></li><li><p>数字类型</p><p>整数(int)、布尔型(bool)、浮点数(float)和复数(complex)。</p><p>int表示为长整型。</p><p>True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。<br>数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。<br>在混合计算时，Python会把整型转换成为浮点数。</p></li><li><p>字符串</p><p>字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</p><p>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</p><p>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</p></li><li><p>空行</p><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p><p>空行与代码缩进不同，空行并不是Python语法的一部分。</p></li><li><p>Print 输出<br>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=“”</p></li><li><p>import 与 from…import</p><p>import 或者 from…import 来导入相应的模块。</p><p>import导入整个模块。</p><p>from…import从某个模块中导入多个函数。</p></li></ul><h5 id="Python3-命令行参数"><a href="#Python3-命令行参数" class="headerlink" title="Python3 命令行参数"></a>Python3 命令行参数</h5><p>Python 提供了 getopt 模块来获取命令行参数。</p><h5 id="Python3-基本数据类型"><a href="#Python3-基本数据类型" class="headerlink" title="Python3 基本数据类型"></a>Python3 基本数据类型</h5><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><h6 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h6><p>Python允许同时为多个变量赋值, 也可以为多个对象指定多个变量。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> b <span class="token operator">=</span> c <span class="token operator">=</span> <span class="token number">1</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'runoob'</span></code></pre><h6 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h6><p>Python3 的六个标准数据类型中:</p><ul><li><p>不可变数据</p><p>Number、String、Tuple</p></li><li><p>可变数据</p><p>List、Dictionary、Set</p></li></ul><p>内置的 type() 函数可以用来查询变量所指的对象类型, 也可用isinstance来判断。</p><p>type()不会认为子类是一种父类类型, isinstance()会认为子类是一种父类类型。</p><p>一个变量可以通过赋值指向不同类型的对象。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span>type<span class="token punctuation">(</span>a<span class="token punctuation">)</span>isinstance<span class="token punctuation">(</span>a<span class="token punctuation">,</span> int<span class="token punctuation">)</span></code></pre><p>可以使用del语句删除一些对象引用。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">del</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d</code></pre><ul><li><p>List</p><p>列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>加号 + 是列表连接运算符，星号 * 是重复操作</p></li><li><p>Tuple</p><p>元组的元素不能修改，但其中可变数据可以修改。</p></li><li><p>set</p><p>元素不重复</p><p>创建一个空集合必须用 set()</p></li><li><p>Dictionary</p><p>键(key)必须使用不可变类型。</p><p>在同一个字典中，键(key)必须是唯一的。</p></li></ul><p>​       创建空字典使用 { }</p><h5 id="python解释器"><a href="#python解释器" class="headerlink" title="python解释器"></a>python解释器</h5><p>Python 解释器不止一种哦，有 CPython、IPython、Jython、PyPy 等。</p><p>Jython 是专为 Java 平台设计的 Python 解释器，它把 Python 代码编译成 Java 字节码执行。</p><h5 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h5><p>1.在python中操作集合或字典中不存在的元素会报错。</p><p>2.右边的表达式会在赋值变动之前执行。右边表达式的执行顺序是从左往右的。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span>    b <span class="token operator">=</span> <span class="token number">2</span>    a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span class="token operator">+</span>b    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 2</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3</span></code></pre><p>3.关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符。</p><p>4.递归以空间换取可读性，当过深时，会造成溢出。</p><h5 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h5><h6 id="ifelse"><a href="#ifelse" class="headerlink" title="ifelse"></a>ifelse</h6><p>if语句的关键字为：if – elif – else。</p><h6 id="while"><a href="#while" class="headerlink" title="while"></a>while</h6><p>在while中可添加else的语句块</p><pre class=" language-python"><code class="language-python">count <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">while</span> count <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>     <span class="token keyword">print</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">" 小于 5"</span><span class="token punctuation">)</span>     count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">else</span><span class="token punctuation">:</span>     <span class="token keyword">print</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token string">" 大于或等于 5"</span><span class="token punctuation">)</span></code></pre><h6 id="for"><a href="#for" class="headerlink" title="for"></a>for</h6><p>for循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p><h6 id="range"><a href="#range" class="headerlink" title="range"></a>range</h6><p>内置range()函数, 会生成数列。</p><h6 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h6><p>pass是空语句，是为了保持程序结构的完整性。</p><h5 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h5><p>1.把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p><p>2.StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p><p>3.yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator。</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 斐波那契</span><span class="token keyword">def</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">></span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>             <span class="token keyword">return</span>        <span class="token keyword">yield</span> a        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a <span class="token operator">+</span> b        counter <span class="token operator">+=</span> <span class="token number">1</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAVEN资源文件变量替换</title>
      <link href="/2019/05/19/maven-zi-yuan-wen-jian-bian-liang-ti-huan/"/>
      <url>/2019/05/19/maven-zi-yuan-wen-jian-bian-liang-ti-huan/</url>
      
        <content type="html"><![CDATA[<p>项目在不同环境下部署时，使用的属性是不同的，这时可以使用MAVEN进行资源文件的过滤，在打包时传递参数，打出适合部署在对应环境的资源文件。</p><p>如定义了如下资源文件:</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">spring.env</span><span class="token punctuation">=</span><span class="token attr-value">${env}</span></code></pre><p>pom文件中可添加如下信息</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--使用了 spring-boot-starter-parent 做项目版本管理，其默认值为@--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource.delimiter</span><span class="token punctuation">></span></span>${}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource.delimiter</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--默认值--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>env</span><span class="token punctuation">></span></span>DEV<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>env</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 配置文件的环境变量 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--可通过includes指定需要进行过滤的文件--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--可通过excludes指定排除需要进行过滤的文件, 这里的路径与上相同, 否则其他文件将不会被打包--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>maven打包命令, 将该环境下需要使用的参数进行传递</p><pre class=" language-script"><code class="language-script">mvn clean install -Denv=PRO</code></pre><p>当参数过多时，可同时使用profiles，将无需保密的参数定义在pom中，通过激活对应profile的形式来进行参数替换。易可通过使用apollo等平台，在此只需动态配置环境即可。</p><pre><code>mvn clean install -P${profileId}</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/cf3bd9ddfe6f" target="_blank" rel="noopener">Maven打包时，环境变量替换,并解决spring-boot项目中${}无效的问题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker实操</title>
      <link href="/2019/04/21/docker-shi-cao/"/>
      <url>/2019/04/21/docker-shi-cao/</url>
      
        <content type="html"><![CDATA[<h4 id="DOCKER安装"><a href="#DOCKER安装" class="headerlink" title="DOCKER安装"></a>DOCKER安装</h4><p>在菜鸟教程中详细提供了linux，windows, mac下的安装操作。</p><h4 id="DOCKER认知"><a href="#DOCKER认知" class="headerlink" title="DOCKER认知"></a>DOCKER认知</h4><p>container是运行的image。容器中的程序不能后台运行，否则容器会终止</p><p>每个容器中只运行一个程序，故可将日志直接输出到控制台上。</p><p>Docker镜像含有启动容器所需要的文件系统及其内容，因此，用于创建并启动docker容器。</p><p>docker inspect 查看docker信息</p><p>docker login/logout 登陆/登出</p><p>docker push 将本地镜像推到远程仓库</p><p>docker save/load 保存/加载镜像</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">Docker 教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LDAP学习与介绍</title>
      <link href="/2019/04/04/ldap-xue-xi-yu-jie-shao/"/>
      <url>/2019/04/04/ldap-xue-xi-yu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>LDAP是轻量目录访问协议(Lightweight Directory Access Protocol)的缩写，其结构用树来表示，而不是用表格。它有优异的读性能，但写性能差，并且没有事务处理、回滚等复杂功能，不适于存储修改频繁的数据。</p><p>LDAP是一种开放Internet标准，LDAP协议是跨平台的Interent协议。</p><p>类似以下的信息适合储存在目录中：</p><ul><li>企业员工信息，如姓名、电话、邮箱等；</li><li>公用证书和安全密钥；</li><li>公司的物理设备信息，如服务器，它的IP地址、存放位置、厂商、购买时间等；</li></ul><h4 id="LDAP组织数据的方式"><a href="#LDAP组织数据的方式" class="headerlink" title="LDAP组织数据的方式"></a>LDAP组织数据的方式</h4><p><img src="/images/ldap_intro_dctree.png" alt="LDAP组织数据的方式"></p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h5><p>条目，也叫记录项，是LDAP中最基本的颗粒，就像字典中的词条，或者是数据库中的记录。通常对LDAP的添加、删除、更改、检索都是以条目为基本对象的。</p><p><code>dn</code>：每一个条目都有一个唯一的标识名（distinguished Name ，DN），如上图中一个 dn：”cn=baby,ou=marketing,ou=people,dc=mydomain,dc=org” 。通过DN的层次型语法结构，可以方便地表示出条目在LDAP树中的位置，通常用于检索。</p><p><code>rdn</code>：一般指dn逗号最左边的部分，如cn=baby。它与RootDN不同，RootDN通常与RootPW同时出现，特指管理LDAP中信息的最高权限用户。</p><p><code>Base DN</code>：LDAP目录树的最顶部就是根，也就是所谓的“Base DN”，如”dc=mydomain,dc=org”。</p><h5 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h5><p>每个条目都可以有很多属性（Attribute），比如常见的人都有姓名、地址、电话等属性。每个属性都有名称及对应的值，属性值可以有单个、多个，比如你有多个邮箱。</p><p><code>属性不是随便定义的，需要符合一定的规则</code>，而这个规则可以通过schema制定。比如，如果一个entry没有包含在 inetorgperson 这个 schema 中的<code>objectClass: inetOrgPerson</code>，那么就不能为它指定employeeNumber属性，因为employeeNumber是在inetOrgPerson中定义的。</p><p>LDAP为人员组织机构中常见的对象都设计了属性(比如commonName，surname)。下面有一些常用的别名：</p><table><thead><tr><th>属性</th><th>别名</th><th>语法</th><th>描述</th><th>值(举例)</th></tr></thead><tbody><tr><td>commonName</td><td>cn</td><td>Directory String</td><td>姓名</td><td>sean</td></tr><tr><td>surname</td><td>sn</td><td>Directory String</td><td>姓</td><td>Chow</td></tr><tr><td>organizationalUnitName</td><td>ou</td><td>Directory String</td><td>单位（部门）名称</td><td>IT_SECTION</td></tr><tr><td>organization</td><td>o</td><td>Directory String</td><td>组织（公司）名称</td><td>example</td></tr><tr><td>telephoneNumber</td><td></td><td>Telephone Number</td><td>电话号码</td><td>110</td></tr><tr><td>objectClass</td><td></td><td></td><td>内置属性</td><td>organizationalPerson</td></tr></tbody></table><h5 id="ObjectClass"><a href="#ObjectClass" class="headerlink" title="ObjectClass"></a>ObjectClass</h5><p>对象类是属性的集合，LDAP预想了很多人员组织机构中常见的对象，并将其封装成对象类。比如人员（person）含有姓（sn）、名（cn）、电话(telephoneNumber)、密码(userPassword)等属性，单位职工(organizationalPerson)是人员(person)的继承类，除了上述属性之外还含有职务（title）、邮政编码（postalCode）、通信地址(postalAddress)等属性。</p><p>通过对象类可以方便的定义条目类型。每个条目可以直接继承多个对象类，这样就继承了各种属性。如果2个对象类中有相同的属性，则条目继承后只会保留1个属性。对象类同时也规定了哪些属性是基本信息，必须含有(Must 活Required，必要属性)：哪些属性是扩展信息，可以含有（May或Optional，可选属性）。</p><p>对象类有三种类型：结构类型（Structural）、抽象类型(Abstract)和辅助类型（Auxiliary）。结构类型是最基本的类型，它规定了对象实体的基本属性，每个条目属于且仅属于一个结构型对象类。抽象类型可以是结构类型或其他抽象类型父类，它将对象属性中共性的部分组织在一起，称为其他类的模板，条目不能直接集成抽象型对象类。辅助类型规定了对象实体的扩展属性。每个条目至少有一个结构性对象类。</p><p>对象类本身是可以相互继承的，所以对象类的根类是top抽象型对象类。以常用的人员类型为例，他们的继承关系：</p><p>!(ObjectClass)[/images/ldap_objectclass.jpg]</p><h5 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h5><p>对象类（ObjectClass）、属性类型（AttributeType）、语法（Syntax）分别约定了条目、属性、值，他们之间的关系如下图所示。所以这些构成了模式(Schema)——对象类的集合。条目数据在导入时通常需要接受模式检查，它确保了目录中所有的条目数据结构都是一致的。</p><p><img src="/images/ldap_schema_attr_entry.jpg" alt="schema"></p><h5 id="LDIF"><a href="#LDIF" class="headerlink" title="LDIF"></a>LDIF</h5><p>LDIF（LDAP Data Interchange Format，数据交换格式）是LDAP数据库信息的一种文本格式，用于数据的导入导出，每行都是“属性: 值”对。</p><h4 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h4><p>在ubuntu上安装未能成功。</p><p>可参考<a href="https://myanbin.github.io/post/openldap-in-centos-7.html" target="_blank" rel="noopener">CentOS 7 环境下 OpenLDAP 的安装与配置</a>在centos上安装成功。</p><p>其中不同点:</p><p>1.chdomain.ldif中{2}mdb中的mdb需通过</p><pre class=" language-shell"><code class="language-shell">ls /etc/openldap/slapd.d/cn=config/ </code></pre><p>此命令查看如下格式文件。</p><p>我本机为olcDatabase={2}hdb.ldif，故我在此书写为hdb。</p><p>2.访问<a href="http://ip/phpldapadmin后出现This" target="_blank" rel="noopener">http://ip/phpldapadmin后出现This</a> base cannot be created with PLA.</p><p>可参考<a href="https://blog.51cto.com/tingdongwang/1733005" target="_blank" rel="noopener">关于OpenLDAPAdmin管理页面提示“This base cannot be created with PLA“问题</a>修改。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://segmentfault.com/a/1190000002607140" target="_blank" rel="noopener">LDAP服务器的概念和原理简单介绍</a></p><p><a href="https://cloud.tencent.com/developer/article/1380076" target="_blank" rel="noopener">OpenLDAP管理工具之LDAP Admin</a></p><p><a href="https://myanbin.github.io/post/openldap-in-centos-7.html" target="_blank" rel="noopener">CentOS 7 环境下 OpenLDAP 的安装与配置</a></p><p><a href="https://blog.51cto.com/tingdongwang/1733005" target="_blank" rel="noopener">关于OpenLDAPAdmin管理页面提示“This base cannot be created with PLA“问题</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springsecurity参考手册</title>
      <link href="/2019/03/30/springsecurity-can-kao-shou-ce/"/>
      <url>/2019/03/30/springsecurity-can-kao-shou-ce/</url>
      
        <content type="html"><![CDATA[<h3 id="创建java配置"><a href="#创建java配置" class="headerlink" title="创建java配置"></a>创建java配置</h3><p><img src="C:%5CUsers%5Cfengchaofan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1553933604145.png" alt="1553933604145"></p><p>1.使用@EnableWebSecurity 注解启用Web安全功能</p><p>2.创建类SecurityConfiguration继承WebSecurityConfigurerAdapter，来对应用中所有的安全相关的事项（所有url，验证用户名密码，表单重定向等）进行控制，这个配置在你的应用程序中创建一个springSecurityFilterChain 的Servlet的过滤器，负责所有安全。</p><p>WebSecurityConfigurerAdapter共有三个configure方法</p><pre><code>configure(WebSecurity) 通过重载，配置Spring Security的Filter链configure(HttpSecurity) 通过重载，配置如何通过拦截器保护请求configure(AuthenticationManagerBuilder) 通过重载，配置user-detail服务</code></pre><h4 id="Filter链配置"><a href="#Filter链配置" class="headerlink" title="Filter链配置"></a>Filter链配置</h4><h4 id="HttpSecurity配置"><a href="#HttpSecurity配置" class="headerlink" title="HttpSecurity配置"></a>HttpSecurity配置</h4><pre><code>protected void configure(HttpSecurity http) throws Exception {    http        .authorizeRequests()            .anyRequest().authenticated()            .and()        .formLogin()            .and()        .httpBasic();}</code></pre><p>上面的默认配置:</p><ul><li>应用中的所有请求都需要用户被认证</li><li>允许用户进行基于表单的认证(WEB可用)</li><li>允许用户使用HTTP基于验证进行认证</li></ul><h4 id="用户存储配置"><a href="#用户存储配置" class="headerlink" title="用户存储配置"></a>用户存储配置</h4><p>configure(AuthenticationManagerBuilder) 方法中可配置多个用户存储。</p><h5 id="JDBC配置"><a href="#JDBC配置" class="headerlink" title="JDBC配置"></a>JDBC配置</h5><pre><code>@Autowiredprivate DataSource dataSource;@Overridepublic void configure(AuthenticationManagerBuilder auth)throws Exception{    //基于数据库的用户存储、认证    auth.jdbcAuthentication().dataSource(dataSource)        .usersByUsernameQuery("select account,password,true from user where account=?")        .authoritiesByUsernameQuery("select account,role from user where account=?")；}</code></pre><h5 id="LDAP配置"><a href="#LDAP配置" class="headerlink" title="LDAP配置"></a>LDAP配置</h5><pre><code>@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {    auth        .ldapAuthentication()            .userDnPatterns("uid={0},ou=people")            .groupSearchBase("ou=groups");}</code></pre><h5 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h5><p>实现接口UserDetailsService的loadUserByUsername(String username)，返回的是代表用户的UserDetails对象。<br>然后通过auth.userDetailsService()方法将其设置到安全配置中,userDetailsService()类似于jdbcAuthentication()和ldapAuthentication()，配置了一个用户存储。</p><h3 id="方法安全"><a href="#方法安全" class="headerlink" title="方法安全"></a>方法安全</h3><p>在任何使用<code>@Configuration</code>的实例上，使用<code>@EnableGlobalMethodSecurity</code>注解来启用基于注解的安全性,添加一个注解到一个方法（或者一个类）限制对相应方法的访问。</p><p>可以在同一个应用程序中启用多种注解，但是在一个接口或者类中只能使用一种类型的注解，否则会出现不明确的行为。如果对特定的方法使用了两个注解，只有其中的一个会被应用。</p><p><img src="C:%5CUsers%5Cfengchaofan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1553938519459.png" alt="1553938519459"></p><p><img src="C:%5CUsers%5Cfengchaofan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1553938541419.png" alt="1553938541419"></p><h3 id="当前用户获取信息"><a href="#当前用户获取信息" class="headerlink" title="当前用户获取信息"></a>当前用户获取信息</h3><p>将如下代码写在类的方法中，交由Spring管理</p><p><img src="C:%5CUsers%5Cfengchaofan%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1554033780770.png" alt="1554033780770"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring security总结</title>
      <link href="/2019/03/10/spring-security-zong-jie/"/>
      <url>/2019/03/10/spring-security-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>应用程序安全性可以归结为差不多两个独立的问题：身份验证（你是谁？）和授权（你可以做什么？）。</p><p>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。</p><h4 id="身份认证和访问控制"><a href="#身份认证和访问控制" class="headerlink" title="身份认证和访问控制"></a>身份认证和访问控制</h4><h5 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h5><p>认证策略的核心接口是 <code>AuthenticationManager</code> 。</p><pre class=" language-JAVA"><code class="language-JAVA">public interface AuthenticationManager {  Authentication authenticate(Authentication authentication)    throws AuthenticationException;}</code></pre><p><code>AuthenticationManager</code> 最常用的实现是 <code>ProviderManager</code>，它委托给一个<code>AuthenticationProvider</code> 实例链。 <code>AuthenticationProvider</code>有点像<code>AuthenticationManager</code>，但它有一个额外的方法来允许调用者询问它是否支持给定的认证类型。</p><p>，AuthenticationManager 接口的常用实现类 ProviderManager 内部会维护一个 List<authenticationprovider> 列表，存放多种认证方式。ProviderManager 中的 List，会依照次序去认证，认证成功则立即返回，若认证失败则返回 null，下一个AuthenticationProvider 会继续尝试认证，如果所有认证器都无法认证成功，则 ProviderManager 会抛出一个 ProviderNotFoundException 异常。</authenticationprovider></p><p>ProviderManager是Authentication的一个实现，并将具体的认证操作委托给一系列的AuthenticationProvider来完成，从而可以实现支持多种认证方式。为了帮助阅读和理解源码具体做了什么，这里删除了原来的一部分注释，并对重要的部分进行了注释说明。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AuthenticationProvider</span> <span class="token punctuation">{</span>    Authentication <span class="token function">authenticate</span><span class="token punctuation">(</span>Authentication var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> AuthenticationException<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>supports()</code> 方法中的<code>Class &lt;?&gt;</code>参数实际上是 <code>Class&lt;? extends Authentication&gt;</code>（它只会被问到是否支持将被传递到 <code>authenticate()</code> 方法的东西）。 一个 <code>ProviderManager</code> 可以通过委托给一个 <code>AuthenticationProviders</code> 链来支持同一个应用程序中的多个不同认证机制。 如果一个 ProviderManager 不能识别一个特定的 <code>Authentication</code> 类型，它将被跳过。</p><p><code>ProviderManager</code> 可以有一个父类认证器，如果所有的提供者返回null，则将再交给父类去认证。 如果父类不可用，则会导致 <code>AuthenticationException</code>。</p><p>有时应用程序具有受保护资源的逻辑组（例如所有与路径模式/ api / **相匹配的Web资源），并且每个组可以具有其自己的专用 <code>AuthenticationManager</code>。 通常，每个人都是一个 <code>ProviderManager</code>，他们共享一个父类。 父母是一种“全局”资源，充当所有提供者的失败回调。</p><p>Spring Security 提供了一些配置帮助类来快速获得应用程序中设置的通用身份验证管理器功能。 最常用的帮助类是 <code>AuthenticationManagerBuilder</code>，它非常适用于设置内存，JDBC或LDAP 中的用户详细信息，或添加自定义的<code>UserDetailsService</code>。 以下是配置全局（父类）<code>AuthenticationManager</code>的应用程序示例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationSecurity</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// web stuff here</span>  <span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">public</span> <span class="token function">initialize</span><span class="token punctuation">(</span>AuthenticationManagerBuilder builder<span class="token punctuation">,</span> DataSource dataSource<span class="token punctuation">)</span> <span class="token punctuation">{</span>    builder<span class="token punctuation">.</span><span class="token function">jdbcAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withUser</span><span class="token punctuation">(</span><span class="token string">"dave"</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">password</span><span class="token punctuation">(</span><span class="token string">"secret"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">roles</span><span class="token punctuation">(</span><span class="token string">"USER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><p>授权核心策略是 <code>AccessDecisionManager</code>， 框架提供了三个实现，并将所有三个委托连接到一个 <code>AccessDecisionVoter</code> 链。</p><p>对象在 <code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code> 的签名中是完全通用的 - 它表示用户可能想要访问的任何内容。</p><p><code>ConfigAttributes</code> 也是相当通用的，用一些元数据表示安全对象的装饰，这些元数据决定了访问它所需的权限级别。</p><p>Spring Security 作为一个单独的过滤器安装在链中，其配置类型为 <code>FilterChainProxy</code>。</p><p>在Spring Boot应用程序中，安全过滤器是ApplicationContext中的<code>@Bean</code>，并具有默认配置，以便将其应用于每个请求。它被安装在由 <code>SecurityProperties.DEFAULT_FILTER_ORDER</code> 定义的位置，而该位置又由<code>FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>（Spring Boot应用程序在包装请求时修改其行为的期望过滤器的最大顺序）决定。</p><p><img src="/images/security-filters.png" alt="1"></p><h5 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h5><h6 id="SecurityContextHolder-SecurityContext和Authentication-对象"><a href="#SecurityContextHolder-SecurityContext和Authentication-对象" class="headerlink" title="SecurityContextHolder, SecurityContext和Authentication 对象"></a>SecurityContextHolder, SecurityContext和Authentication 对象</h6><p>最根本的对象是<code>SecurityContextHolder，应用程序的当前安全环境的细节存储到它里边，它也包含了应用当前使用的主体细节。默认情况下</code>SecurityContextHolder<code>使用</code>ThreadLocal存储这些信息，这意味着，安全环境在同一个线程执行的方法一直是有效的， 即使这个安全环境没有作为一个方法参数传递到那些方法里。</p><h5 id="FILTER"><a href="#FILTER" class="headerlink" title="FILTER"></a>FILTER</h5><pre><code>UsernamePasswordAuthenticationFilter</code></pre><p>在Spring Security中,保存<code>SecurityContext</code>的任务落在了<code>SecurityContextPersistenceFilter</code>身上，</p><h4 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h4><h5 id="创建Spring-Security的Java-配置类"><a href="#创建Spring-Security的Java-配置类" class="headerlink" title="创建Spring Security的Java 配置类"></a>创建Spring Security的Java 配置类</h5><ul><li><p>创建类SecurityConfiguration继承WebSecurityConfigurerAdapter，来对应用中所有的安全相关的事项（所有url，验证用户名密码，表单重定向等）进行控制，这个配置在你的应用程序中创建一个springSecurityFilterChain 的Servlet的过滤器。</p></li><li><p>@EnableWebSecurity 注解启用Web安全功能。</p></li><li><p>初始化springSecurityFilter注册类，继承类AbstractSecurityWebApplicationInitializer。</p><p>WebSecurityConfigurerAdapter共有三个configure方法</p></li></ul><pre><code>configure(WebSecurity) 通过重载，配置Spring Security的Filter链configure(HttpSecurity) 通过重载，配置如何通过拦截器保护请求configure(AuthenticationManagerBuilder) 通过重载，配置user-detail服务</code></pre><h5 id="密码加密策略"><a href="#密码加密策略" class="headerlink" title="密码加密策略"></a>密码加密策略</h5><ul><li><p>NoOpPasswordEncoder 明文方式保存</p></li><li><p>BCtPasswordEncoder 强hash方式加密</p></li><li><p>StandardPasswordEncoder SHA-256方式加密</p></li><li><p>实现PasswordEncoder接口,自定义加密方式</p><p>通过方法passwordEncoder传入对应的加密实例即可。</p></li></ul><h5 id="请求拦截策略"><a href="#请求拦截策略" class="headerlink" title="请求拦截策略"></a>请求拦截策略</h5><p>spring security的请求拦截匹配有两种风格，ant风格和正则表达式风格。编码方式是通过重载configure(HttpSecurity)方法实现。</p><pre><code>access(String)     如果给定的SpEL表达式计算结果为true，就允许访问anonymous()        允许匿名用户访问authenticated()    允许认证过的用户访问denyAll()          无条件拒绝所有访问fullyAuthenticated()   如果用户是完整认证的话（不是通过Remember-me功能认证的），就允许访问hasAnyAuthority(String...)   如果用户具备给定权限中的某一个的话，就允许访问hasAnyRole(String...)   如果用户具备给定角色中的某一个的话，就允许访问hasAuthority(String)   如果用户具备给定权限的话，就允许访问hasIpAddress(String)   如果请求来自给定IP地址的话，就允许访问hasRole(String)   如果用户具备给定角色的话，就允许访问not()   对其他访问方法的结果求反permitAll()   无条件允许访问rememberMe()   如果用户是通过Remember-me功能认证的，就允许访问</code></pre><h5 id="remember-me功能"><a href="#remember-me功能" class="headerlink" title="remember-me功能"></a>remember-me功能</h5><p>未完待续</p><h5 id="防止CSRF"><a href="#防止CSRF" class="headerlink" title="防止CSRF"></a>防止CSRF</h5><p>未完待续</p><h5 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h5><p>未完待续</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/76bfa6743ba9" target="_blank" rel="noopener">spring security 入门教程 简书</a></p><p><a href="http://www.spring4all.com/article/554" target="_blank" rel="noopener">Spring 官方教程：Spring Security 架构</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker开发指南阅读总结</title>
      <link href="/2019/02/25/docker-kai-fa-zhi-nan-yue-du-zong-jie/"/>
      <url>/2019/02/25/docker-kai-fa-zhi-nan-yue-du-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>容器是轻量且可移植的仓库，包含应用程序及其依赖的组件。</p><p>容器中主进程运行多久，容器就运行多久。</p><p>Docker容器使用联合文件系统(union file system, UFS)，它允许多个文件系统以层级方式挂载，并表现为一个单一的文件系统。镜像的文件系统以只读的方式挂载，任何对运行中容器的改变则只会发生在它之上的可读写层。</p><p>Dockerfile里的每个指令都会创建一个新的层，而这个层将位于前一个层之上。由于不必要的层会使镜像变得臃肿，因此Dockerfile会把多个UNIX命令放在同一个RUN指令中，以减少层的数量。</p><p>数据卷是直接在主机挂载的文件或目录，不属于常规联合文件系统的一部分，它们允许与其他容器共享，而任何修改都会直接发生在主机的文件系统里。声明一个目录为数据卷有两种方法,第一种是在Dockerfile 里使用VOLUME 指令,第二种是在执行docker run 的时候使用-v 参数, 执行docker run 命令的时候可以指定用于挂载的主机目录。</p><p>一个常用的做法是创建数据容器，这种容器的唯一目的就是与其他容器分享数据，没有必要让数据容器一直运行。</p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p>docker run </p><p> -it  以交互的方式运行容器</p><p> -h  设定一个新的主机名</p><p> –rm 当容器退出时，容器和相关的文件系统会被一并删掉</p><p> –link 把容器连接起来(不推荐使用)</p><p>  -v HOST_DIR:CONTAINER_DIR</p><p>  -p: 指定端口映射，格式为：主机(宿主)端口:容器端口</p><p>docker diff  (容器的名称或ID) 查看有哪些文件被改动过</p><p>docker inspect (容器的名称或ID) 获取更多关于容器的信息</p><p>docker logs (容器的名称或ID)  得知这个容器里曾经发生过的一切事情</p><p>docker commit 将容器转为镜像(无论是在运行状态还是停止状态)</p><p>docker search 搜索已有的镜像</p><p>docker push 推镜像到仓库中</p><p>docker rm 删除一个或多个容器</p><p>  -v 删除与容器关联的卷(不是绑定挂载，或正被其他容器使用)</p><p>  -l 移除容器间的网络连接,而非容器本身</p><p>  -f 通过SIGKILL信号强制删除一个正在运行的容器</p><p>docker ps 列出正在运行容器</p><p>  -a 显示所有的容器,包括未运行的</p><p>  -f 根据条件过滤显示的内容(条件为指定,不在此列出,使用时可进行查询)</p><p>  –format 指定返回值的模板文件</p><p>  -l 显示最后被创建的容器</p><p>  -n 列出最近创建的n个容器</p><p>  –no-trunc 不截断输出,显示完整输出</p><p>  -q 静默模式,只显示容器编号</p><p>  -s 显示总的文件大小</p><p>docker pause  暂停容器中所有的进程。</p><p>docker unpause  恢复容器中所有的进程。</p><p>docker history 查看组成镜像的所有层</p><p>docker attach 允许用户查看容器内的主进程，与它进行交互</p><p>docker cp 在容器和主机之间复制文件和目录</p><p>docker exec 在容器中执行一个命令，用于执行维护工作</p><h4 id="实用命令"><a href="#实用命令" class="headerlink" title="实用命令"></a>实用命令</h4><p>docker ps -aq -f status=exited 得到所有已停止容器的id。</p><p>docker rm -v $(docker ps -aq -f status=exited) 删除所有已停止的容器。</p><p>docker run –restart on-failure:5 当退出值为非0时，将尝试重启5次，之后便会放弃。</p><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>Dockerfile 是一个描述如何创建Docker 镜像所需步骤的文本文件。</p><p>所有Dockerfile 一定要有FROM 指令作为第一个非注释指令，FROM 指令指定初始镜像。</p><p>RUN 命令指定在镜像中运行的shell命令。</p><p>ENTRYPOINT 指令让我们指定一个可执行文件，同时还能处理传给docker run 的参数。</p><h4 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h4><h5 id="Docker系统架构"><a href="#Docker系统架构" class="headerlink" title="Docker系统架构"></a>Docker系统架构</h5><p><img src="/images/docker_structure.png" alt="1551711321388"></p><p>1.Docker 守护进程，它负责容器的创建、运行和监控，还负责镜像的构建和储存 ，容器和镜像都在图的右边。</p><p>2.Docker 客户端在图的左边，它通过HTTP 与Docker 守护进程通信，值得一提的是，Docker 客户端和守护进<br>程是由同一个二进制文件发布的。</p><p>3.Docker 寄存服务负责储存和发布镜像。</p><h5 id="镜像生成"><a href="#镜像生成" class="headerlink" title="镜像生成"></a>镜像生成</h5><p>docker build命令需Dockerfile和构建环境的上下文。</p><p>上下文是一组本地文件和目录，它可以被Dockerfile 的 ADD 或 COPY 指令所引用，通常以目录路径的形式指定。</p><p>从构建环境的上下文中排除不必要的文件，可以使用 .dockerignore 文件。</p><pre class=" language-XML"><code class="language-XML">当构建失败时，可以把失败前的那个层启动起来，这非常有助于调试。如果需要使缓存失效，可以在执行docker build 的时候加上--no-cache 参数。不同的镜像会共享相同的基础镜像层，</code></pre><h6 id="Dockerfile-的指令"><a href="#Dockerfile-的指令" class="headerlink" title="Dockerfile 的指令"></a>Dockerfile 的指令</h6><p>Dockerfile 的注释方法是以# 作为一行的开头。</p><p>1.ADD 从构建环境的上下文或远程URL 复制文件至镜像。</p><p>2.CMD 当容器启动时执行指定的指令。</p><p>3.COPY 用于从构建环境的上下文复制文件至镜像。</p><p>4.ENTRYPOINT 设置一个于容器启动时运行的可执行文件（以及默认参数）</p><p>5.ENV 设置镜像内的环境变量。</p><p>6.EXPOSE 向Docker 表示该容器将会有一个进程监听所指定的端口。</p><p>7.FROM 设置Dockerfile 使用的基础镜像。</p><p>8.MAINTAINER 通常用于设置镜像维护者的姓名和联系方式。</p><p>9.ONBUILD 指定当镜像被用作另一个镜像的基础镜像时将会执行的指令。</p><p>10.RUN 在容器内执行指定的指令，并把结果保存下来。</p><p>11.USER 设置任何后续的RUN、CMD 或ENTRYPOINT 指令执行时所用的用户（用户名或UID）</p><p>12.VOLUME 指定为数据卷的文件或目录。</p><p>13WORKDIR 对任何后续的RUN、CMD、ENTRYPOINT、ADD 或COPY 指令设置工作目录。</p><h5 id="通过compose实现容器自动化"><a href="#通过compose实现容器自动化" class="headerlink" title="通过compose实现容器自动化"></a>通过compose实现容器自动化</h5><p>Compose将使我们免于自己维护用于服务编排的脚本，包括启动、连接、更新和停止容器。</p><p>使用Compose常用的命令</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">up</span><span class="token punctuation">:</span>  启动所有在Compose 文件中定义的容器，并且把它们的日志信息汇集一起。通常会使用<span class="token punctuation">-</span>d 参数使Compose 在后台运行。<span class="token key atrule">build</span><span class="token punctuation">:</span> 重新建造由Dockerfile 构建的镜像。除非镜像不存在，否则up 命令不会执行构建的动作，因此需要更新镜像时便使用这个命令。<span class="token key atrule">ps</span><span class="token punctuation">:</span> 获取由Compose管理的容器的状态信息。<span class="token key atrule">run</span><span class="token punctuation">:</span> 启动一个容器，并运行一个一次性的命令。被连接的容器会同时启动，除非用了<span class="token punctuation">-</span><span class="token punctuation">-</span>nodeps参数。<span class="token key atrule">logs</span><span class="token punctuation">:</span> 汇集由Compose管理的容器的日志，并以彩色输出。<span class="token key atrule">stop</span><span class="token punctuation">:</span> 停止容器，但不会删除它们。<span class="token key atrule">rm</span><span class="token punctuation">:</span> 删除已停止的容器。不要忘记使用<span class="token punctuation">-</span>v 参数来删除任何由Docker 管理的数据卷。</code></pre><h5 id="镜像分发"><a href="#镜像分发" class="headerlink" title="镜像分发"></a>镜像分发</h5><p>从Dockerfile重新构建、从寄存服务器下载，或通docker load命令从归档文件安装。</p><p>待续。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAVEN实战阅读总结</title>
      <link href="/2019/02/17/maven-shi-zhan-yue-du-zong-jie/"/>
      <url>/2019/02/17/maven-shi-zhan-yue-du-zong-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Maven不仅是构建工具，还是一个依赖管理工具和项目信息管理工具，约定优于配置。</p><p>Maven会自动解析所有项目的直接依赖和传递性依赖，对于一些依赖冲突，也能进行调节，以确保任何一个构建只有唯一的版本在依赖中存在，最后得到的依赖被称为已解析依赖。</p><p>坐标和依赖是任何一个构件在Maven世界中的逻辑表示方式；构件的物理表示方式是文件，Maven通过仓库来统一管理这些文件。</p><p>对于Maven来说，基于发布版本，同样的坐标和版本意味着同样的构建，若本地仓库包含，则不会对照远程仓库进行更新。快照版本会根据时间戳对比，找到最新文件，快照版本只在组织内部或模块之间的依赖使用。</p><p>Maven还有两个核心概念是声明周期和插件。Maven声明周期是抽象的，其实际行为由插件来完成，两者协同工作，密不可分。</p><p>Maven的聚合特性能将项目的各个模块聚合在一起构建，继承特性能抽取各模块相同的依赖和插件等配置，保持各个模块的一致性。</p><h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>Maven依赖管理的底层基础是坐标，一组Maven坐标是通过一些元素来定义的，他们是groupId，artifactId，version，packaging，classifier(用来帮助定义构建输出的一些附属构件，与主构件对应，不能直接定义项目的classifier)。</p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><h5 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h5><p>依赖范围用来控制依赖于编译、测试、运行这三种classpath的关系。</p><p>依赖传递时的关系如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围。</p><p><img src="/images/scope.jpg" alt=""></p><h5 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h5><p>当依赖冲突时，Maven依赖调解的第一原则是:路径最近着优先；第二原则是第一生命者优先。</p><h5 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h5><p>声明如下。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.1.46<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>根据单一职责性原则，在理想情况下，不应该使用可选项依赖。</p><h4 id="mvn-dependency"><a href="#mvn-dependency" class="headerlink" title="mvn dependency"></a>mvn dependency</h4><h5 id="mvn-dependency-list"><a href="#mvn-dependency-list" class="headerlink" title="mvn dependency : list"></a>mvn dependency : list</h5><p>显示所有已解析依赖，同时，每个依赖的范围也得以明确标识。</p><h5 id="mvn-dependency-tree"><a href="#mvn-dependency-tree" class="headerlink" title="mvn dependency : tree"></a>mvn dependency : tree</h5><p>查看当前项目的依赖树。</p><h5 id="mvn-dependency-analyze"><a href="#mvn-dependency-analyze" class="headerlink" title="mvn dependency : analyze"></a>mvn dependency : analyze</h5><p>帮助分析当前项目的依赖。</p><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>Maven仓库是基于简单文件系统存储的，路径与坐标的大致对应关系为groupId/artifactId/version/artifactId-version.packaging.</p><p>Maven仓库的分类如下图所示。</p><p><img src="/images/maven-%E4%BB%93%E5%BA%93%E5%88%86%E7%B1%BB.jpg" alt=""></p><p>自定义本地仓库目录的地址</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- setting.xml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localRepository</span><span class="token punctuation">></span></span>E://maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localRepository</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>setting</span><span class="token punctuation">></span></span></code></pre><p>远程仓库配置(可直接配置在pom文件中)</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repositories</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repository</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 任何一个仓库的ID必须是唯一的 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>jboss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>JBoss Repository<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 仓库的地址 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://repository.jboss.com/maven2/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 表示仓库布局是Maven2和Maven3的默认布局 --></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span><span class="token punctuation">></span></span>default<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>releases</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enabled</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>enabled</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 从远程仓库检查更新的频率(每隔3分钟检查一次)--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>updatePolicy</span><span class="token punctuation">></span></span>interval: 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>updatePolicy</span><span class="token punctuation">></span></span>                <span class="token comment" spellcheck="true">&lt;!-- 检查文件的策略(遇到校验错误构建失败) --></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>checksumPolicy</span><span class="token punctuation">></span></span>fail<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>checksumPolicy</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>releases</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>snapshots</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>enabled</span><span class="token punctuation">></span></span>false<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>enabled</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>snapshots</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repository</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repositories</span><span class="token punctuation">></span></span></code></pre><p>远程仓库认证</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- setting.xml --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servers</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>server</span><span class="token punctuation">></span></span>      <span class="token comment" spellcheck="true">&lt;!-- id与需要认证的repository元素的id保持一致 --></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>jboss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>username</span><span class="token punctuation">></span></span>repouser<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>username</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>password</span><span class="token punctuation">></span></span>repopwd<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>password</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>server</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servers</span><span class="token punctuation">></span></span></code></pre><p>将项目生成的构建部署到仓库中</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span><span class="token punctuation">></span></span>    ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>distributionManagement</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 发布版本的仓库 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>repository</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>releases<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>${releases.repo}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>repository</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- 快照版本的仓库 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>snapshotRepository</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>snapshots<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>${snapshots.repo}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>snapshotRepository</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>distributionManagement</span><span class="token punctuation">></span></span>    ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。关于镜像更为常见的做法是结合私服，这可以将仓库配置集中到私服，私服就是所有仓库的镜像，简化Maven本身的配置。</p><p>当镜像仓库不稳定或无法提供服务时，仍将无法访问被镜像仓库。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrors</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>mirrorId<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">></span></span>*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Human Readable Name for this Mirror.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">></span></span>http://my.repository.com/repo/path<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrors</span><span class="token punctuation">></span></span></code></pre><p><img src="/images/mirrors.jpg" alt=""></p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Maven生命周期就是为了对所有构建过程进行抽象和统一，包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署，和站点生成等几乎所有的构建步骤，但生命周期本身不做任何实际的工作。</p><p>根据插件机制，每个构建步骤可以绑定一个或多个插件行为。</p><p>Maven有三套独立的生命周期：clean(清理项目)、default（构建项目）、site(建立项目站点)。</p><p><img src="/images/clean.jpg" alt=""></p><p><img src="/images/site.jpg" alt=""></p><p><img src="/images/default.jpg" alt=""></p><p>每个生命周期是相互独立的，但一个生命周期的阶段是有前后依赖关系的。</p><h4 id="插件目标"><a href="#插件目标" class="headerlink" title="插件目标"></a>插件目标</h4><p>一个插件里的每个功能就是一个插件目标，例如maven-dependency-plugin插件能分别对应的目标为dependency:tree,dependency:list,dependency:analyze等，这是一种通用写法，冒号前面是插件，冒号后面是该插件的目标。</p><h4 id="自定义绑定"><a href="#自定义绑定" class="headerlink" title="自定义绑定"></a>自定义绑定</h4><p>用户自己选择将某个插件目标绑定到生命周期的某个阶段上。</p><p>在bulid元素下的plugins子元素中声明插件的使用。</p><p><a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="noopener">Maven在线插件文档</a></p><p>在pom中定义插件时，如果是Maven的官方插件，可以省略掉groupId，Maven内部插件解析机制会进行处理。</p><h4 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h4><h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><p><img src="/images/aggreate.jpg" alt=""></p><p>packing值为pom，且配置modules。</p><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p><img src="/images/extend.png" alt="1550760187230"></p><p>可继承的POM元素</p><p>groupId：项目组ID，项目坐标的核心元素。</p><p>version：项目版本，项目坐标的核心元素。</p><p>description：项目的描述信息。</p><p>organization：项目的组织信息。</p><p>inceptionYear：项目的创始年份。</p><p>url：项目的URL地址。</p><p>developers：项目的开发者信息。</p><p>contributors：项目的开发者信息。</p><p>distributionManagement：项目的部署配置。</p><p>issueManagement：项目的缺陷跟踪系统信息。</p><p>ciManagement：项目的持续集成系统信息。</p><p>scm：项目的版本控制系统信息。</p><p>mailingLists：项目的邮件列表信息。</p><p>properties：自定义的Maven属性。</p><p>dependencies：项目的依赖配置。</p><p>dependencyManagement：项目的依赖管理配置。</p><p>repositories：项目的仓库配置。</p><p>build：包括项目的源码目录配置：输出目录配置、插件配置、插件管理配置等。</p><p>reporting：包括项目的报告输出目录配置、报告插件配置等。</p><p>在dependencyManagement元素下的依赖不会引入实际的依赖，不过它能够约束dependencies下的依赖使用，子模块只需配置简单的groupId和artifactId就能引入正确的依赖。</p><p>import范围依赖可以导入另一pom中的dependencyManagement配置。</p><p><img src="/images/import.png" alt="1550763166979"></p><p>指向了打包类型为pom的模块。</p><h5 id="插件管理"><a href="#插件管理" class="headerlink" title="插件管理"></a>插件管理</h5><h5 id="反应堆"><a href="#反应堆" class="headerlink" title="反应堆"></a>反应堆</h5><p>即所有模块组成的构建结构，可以通过裁剪反应堆，指定构建顺序。</p><h4 id="Nexus"><a href="#Nexus" class="headerlink" title="Nexus"></a>Nexus</h4><p>nexus的关注点功能有:建立各种类型的仓库，权限管理功能，调度任务功能等。</p><h4 id="Maven测试"><a href="#Maven测试" class="headerlink" title="Maven测试"></a>Maven测试</h4><p>Maven的maven-surefire-plugin会自动自动执行测试源码路径中以<strong>Test</strong>开头和以<strong>Test</strong>或<strong>TestCase</strong>结尾的Java类。</p><p>maven-surefire-plugin是maven背后真正执行测试的插件。</p><p>cobertura-maven-plugin能生成测试覆盖率报告，mvn cobertura:cobertura.</p><h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><p>快速且高效率的<strong>自动</strong>构建项目的所有源码，并为项目成员提供丰富的反馈信息。</p><p>文中主要介绍的Hudson为Jenkins前身。</p><h4 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h4><p><img src="/images/version.png" alt="1551012419884"></p><p>主版本表示了项目的重大架构变更，次版本表示较大范围的功能增加和变化，增量版本表示重大bug的修复，里程碑版本表示某一版本的里程碑，但还不是非常稳定。</p><p>对于里程碑版本只是简单的字符串比较，一次会得到1.2-beta-3&gt;1.2-beta-11，这一点需要留意。</p><h5 id="Maven-Release-Plugin"><a href="#Maven-Release-Plugin" class="headerlink" title="Maven Release Plugin"></a>Maven Release Plugin</h5><p>此插件的目标:prepare,rollback,perform,branch。</p><h5 id="项目的scm信息配置"><a href="#项目的scm信息配置" class="headerlink" title="项目的scm信息配置"></a>项目的scm信息配置</h5><p><img src="/images/scm.png" alt="1551013437812"></p><p>connection表示只读的scm地址，url表示浏览器中访问的地址，developerConnection表示可写的地址。</p><h4 id="灵活的构建"><a href="#灵活的构建" class="headerlink" title="灵活的构建"></a>灵活的构建</h4><h5 id="Maven属性"><a href="#Maven属性" class="headerlink" title="Maven属性"></a>Maven属性</h5><p>内置属性，POM属性，自定义属性，setting属性，java系统属性和环境变量属性。</p><h5 id="资源过滤"><a href="#资源过滤" class="headerlink" title="资源过滤"></a>资源过滤</h5><p><img src="/images/resources.png" alt="1551016659519"></p><p>目的为Maven解析资源文件中的Maven属性，进行替换。</p><h4 id="编写maven插件"><a href="#编写maven插件" class="headerlink" title="编写maven插件"></a>编写maven插件</h4><p>步骤如下:</p><p>​    1.创建maven项目，packing为maven-plugin；</p><p>​    2.为插件编写目标(MoJo),必须继承自AbstractMoJo，并实现execute方法;</p><p>​    3.为目标提供配置点(@parameter)；</p><p>​    4.编写代码实现目标行为；</p><p>​    5.错误处理及日志；</p><p>​    6.测试插件。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea好用的快捷键</title>
      <link href="/2019/01/27/idea-hao-yong-de-kuai-jie-jian/"/>
      <url>/2019/01/27/idea-hao-yong-de-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h5 id="定位到类的位置"><a href="#定位到类的位置" class="headerlink" title="定位到类的位置"></a>定位到类的位置</h5><p>使用<code>alt+F1</code>，弹出<code>Select in</code>视图，然后选择<code>Project View</code>，回车。</p><h5 id="使用快捷键移动分割线"><a href="#使用快捷键移动分割线" class="headerlink" title="使用快捷键移动分割线"></a>使用快捷键移动分割线</h5><p><code>alt+1</code>把鼠标焦点定位到<code>project</code>视图里，然后直接使用<code>ctrl+shift+左右箭头</code>来移动分割线。</p><h5 id="取消单行显示tabs的操作"><a href="#取消单行显示tabs的操作" class="headerlink" title="取消单行显示tabs的操作"></a>取消单行显示tabs的操作</h5><p><img src="/images/1.jpg" alt="1"></p><h5 id="滚轴修改字体大小"><a href="#滚轴修改字体大小" class="headerlink" title="滚轴修改字体大小"></a>滚轴修改字体大小</h5><p><img src="/images/2.jpg" alt="2"></p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://www.iocoder.cn/tags/IntelliJ-IDEA/" target="_blank" rel="noopener">芋道源码-idea</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>钗头凤</title>
      <link href="/2018/12/31/chai-tou-feng/"/>
      <url>/2018/12/31/chai-tou-feng/</url>
      
        <content type="html"><![CDATA[<h2 id="钗头凤·红酥手-陆游"><a href="#钗头凤·红酥手-陆游" class="headerlink" title="钗头凤·红酥手   陆游"></a>钗头凤·红酥手   陆游</h2><p>红酥手，黄縢酒。满城春色宫墙柳。东风恶，欢情薄。一杯愁绪，几年离索。错、错、错。 </p><p>春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫。</p><h2 id="钗头凤·世情薄-唐氏"><a href="#钗头凤·世情薄-唐氏" class="headerlink" title="钗头凤·世情薄   唐氏"></a>钗头凤·世情薄   唐氏</h2><p>世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残，欲笺心事，独语斜阑。难，难，难！</p><p>人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊，怕人寻问，咽泪装欢。瞒，瞒，瞒！​      ​               </p><pre><code>说不完的离愁，诉不尽的相思。        世人皆苦，唯心不易。</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
